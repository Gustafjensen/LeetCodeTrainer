[
  {
    "id": "two-sum",
    "title": "Two Sum",
    "difficulty": "Easy",
    "description": "Given an array of integers `nums` and an integer `target`, return indices of the two numbers such that they add up to `target`.\n\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\n\nYou can return the answer in any order.",
    "examples": [
      {
        "input": "nums = [2,7,11,15], target = 9",
        "output": "[0, 1]",
        "explanation": "Because nums[0] + nums[1] == 9, we return [0, 1]."
      },
      {
        "input": "nums = [3,2,4], target = 6",
        "output": "[1, 2]",
        "explanation": null
      }
    ],
    "functionSignature": "def twoSum(nums: list[int], target: int) -> list[int]:",
    "starterCode": "def twoSum(nums: list[int], target: int) -> list[int]:\n    # Write your solution here\n    pass",
    "tags": ["Arrays", "Hash Map"]
  },
  {
    "id": "reverse-string",
    "title": "Reverse String",
    "difficulty": "Easy",
    "description": "Write a function that reverses a list of characters in place.\n\nDo not allocate extra space for another array. You must do this by modifying the input list in-place with O(1) extra memory.",
    "examples": [
      {
        "input": "s = [\"h\",\"e\",\"l\",\"l\",\"o\"]",
        "output": "[\"o\",\"l\",\"l\",\"e\",\"h\"]",
        "explanation": null
      },
      {
        "input": "s = [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]",
        "output": "[\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]",
        "explanation": null
      }
    ],
    "functionSignature": "def reverseString(s: list[str]) -> list[str]:",
    "starterCode": "def reverseString(s: list[str]) -> list[str]:\n    # Modify s in-place and return it\n    pass",
    "tags": ["Two Pointers", "Strings"]
  },
  {
    "id": "fizz-buzz",
    "title": "FizzBuzz",
    "difficulty": "Easy",
    "description": "Given an integer `n`, return a string array `answer` (1-indexed) where:\n\n- `answer[i] == \"FizzBuzz\"` if `i` is divisible by 3 and 5.\n- `answer[i] == \"Fizz\"` if `i` is divisible by 3.\n- `answer[i] == \"Buzz\"` if `i` is divisible by 5.\n- `answer[i] == i` (as a string) if none of the above conditions are true.",
    "examples": [
      {
        "input": "n = 3",
        "output": "[\"1\",\"2\",\"Fizz\"]",
        "explanation": null
      },
      {
        "input": "n = 5",
        "output": "[\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\"]",
        "explanation": null
      },
      {
        "input": "n = 15",
        "output": "[\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\",\"Fizz\",\"7\",\"8\",\"Fizz\",\"Buzz\",\"11\",\"Fizz\",\"13\",\"14\",\"FizzBuzz\"]",
        "explanation": null
      }
    ],
    "functionSignature": "def fizzBuzz(n: int) -> list[str]:",
    "starterCode": "def fizzBuzz(n: int) -> list[str]:\n    # Write your solution here\n    pass",
    "tags": ["Math", "Simulation"]
  },
  {
    "id": "valid-palindrome",
    "title": "Valid Palindrome",
    "difficulty": "Easy",
    "description": "A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.\n\nGiven a string `s`, return `true` if it is a palindrome, or `false` otherwise.",
    "examples": [
      {
        "input": "s = \"A man, a plan, a canal: Panama\"",
        "output": "true",
        "explanation": "\"amanaplanacanalpanama\" is a palindrome."
      },
      {
        "input": "s = \"race a car\"",
        "output": "false",
        "explanation": "\"raceacar\" is not a palindrome."
      },
      {
        "input": "s = \" \"",
        "output": "true",
        "explanation": "After removing non-alphanumeric characters, s is an empty string."
      }
    ],
    "functionSignature": "def isPalindrome(s: str) -> bool:",
    "starterCode": "def isPalindrome(s: str) -> bool:\n    # Write your solution here\n    pass",
    "tags": ["Strings", "Two Pointers"]
  },
  {
    "id": "climbing-stairs",
    "title": "Climbing Stairs",
    "difficulty": "Easy",
    "description": "You are climbing a staircase. It takes `n` steps to reach the top.\n\nEach time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?",
    "examples": [
      {
        "input": "n = 2",
        "output": "2",
        "explanation": "There are two ways to climb to the top: 1+1 and 2."
      },
      {
        "input": "n = 3",
        "output": "3",
        "explanation": "There are three ways to climb to the top: 1+1+1, 1+2, and 2+1."
      }
    ],
    "functionSignature": "def climbStairs(n: int) -> int:",
    "starterCode": "def climbStairs(n: int) -> int:\n    # Write your solution here\n    pass",
    "tags": ["Dynamic Programming", "Recursion"]
  },
  {
    "id": "contains-duplicate",
    "title": "Contains Duplicate",
    "difficulty": "Easy",
    "description": "Given an integer array `nums`, return `true` if any value appears at least twice in the array, and return `false` if every element is distinct.",
    "examples": [
      {
        "input": "nums = [1,2,3,1]",
        "output": "true",
        "explanation": null
      },
      {
        "input": "nums = [1,2,3,4]",
        "output": "false",
        "explanation": null
      },
      {
        "input": "nums = [1,1,1,3,3,4,3,2,4,2]",
        "output": "true",
        "explanation": null
      }
    ],
    "functionSignature": "def containsDuplicate(nums: list[int]) -> bool:",
    "starterCode": "def containsDuplicate(nums: list[int]) -> bool:\n    # Write your solution here\n    pass",
    "tags": ["Arrays", "Hash Map"]
  },
  {
    "id": "valid-anagram",
    "title": "Valid Anagram",
    "difficulty": "Easy",
    "description": "Given two strings `s` and `t`, return `true` if `t` is an anagram of `s`, and `false` otherwise.\n\nAn anagram is a word formed by rearranging the letters of a different word, using all the original letters exactly once.",
    "examples": [
      {
        "input": "s = \"anagram\", t = \"nagaram\"",
        "output": "true",
        "explanation": null
      },
      {
        "input": "s = \"rat\", t = \"car\"",
        "output": "false",
        "explanation": null
      }
    ],
    "functionSignature": "def isAnagram(s: str, t: str) -> bool:",
    "starterCode": "def isAnagram(s: str, t: str) -> bool:\n    # Write your solution here\n    pass",
    "tags": ["Strings", "Hash Map"]
  },
  {
    "id": "palindrome-number",
    "title": "Palindrome Number",
    "difficulty": "Easy",
    "description": "Given an integer `x`, return `true` if `x` is a palindrome, and `false` otherwise.\n\nAn integer is a palindrome when it reads the same backward as forward. For example, 121 is a palindrome while 123 is not.",
    "examples": [
      {
        "input": "x = 121",
        "output": "true",
        "explanation": "121 reads as 121 from left to right and from right to left."
      },
      {
        "input": "x = -121",
        "output": "false",
        "explanation": "From left to right, it reads -121. From right to left it becomes 121-."
      },
      {
        "input": "x = 10",
        "output": "false",
        "explanation": "Reads 01 from right to left."
      }
    ],
    "functionSignature": "def isPalindromeNumber(x: int) -> bool:",
    "starterCode": "def isPalindromeNumber(x: int) -> bool:\n    # Write your solution here\n    pass",
    "tags": ["Math"]
  },
  {
    "id": "roman-to-integer",
    "title": "Roman to Integer",
    "difficulty": "Easy",
    "description": "Roman numerals are represented by seven symbols: I (1), V (5), X (10), L (50), C (100), D (500), M (1000).\n\nGiven a roman numeral string, convert it to an integer.\n\nSubtraction is used when a smaller value appears before a larger value (e.g. IV = 4, IX = 9).",
    "examples": [
      {
        "input": "s = \"III\"",
        "output": "3",
        "explanation": "III = 3"
      },
      {
        "input": "s = \"LVIII\"",
        "output": "58",
        "explanation": "L = 50, V = 5, III = 3"
      },
      {
        "input": "s = \"MCMXCIV\"",
        "output": "1994",
        "explanation": "M = 1000, CM = 900, XC = 90, IV = 4"
      }
    ],
    "functionSignature": "def romanToInt(s: str) -> int:",
    "starterCode": "def romanToInt(s: str) -> int:\n    # Write your solution here\n    pass",
    "tags": ["Math", "Strings"]
  },
  {
    "id": "longest-common-prefix",
    "title": "Longest Common Prefix",
    "difficulty": "Easy",
    "description": "Write a function to find the longest common prefix string amongst an array of strings.\n\nIf there is no common prefix, return an empty string \"\".",
    "examples": [
      {
        "input": "strs = [\"flower\",\"flow\",\"flight\"]",
        "output": "\"fl\"",
        "explanation": null
      },
      {
        "input": "strs = [\"dog\",\"racecar\",\"car\"]",
        "output": "\"\"",
        "explanation": "There is no common prefix among the input strings."
      }
    ],
    "functionSignature": "def longestCommonPrefix(strs: list[str]) -> str:",
    "starterCode": "def longestCommonPrefix(strs: list[str]) -> str:\n    # Write your solution here\n    pass",
    "tags": ["Strings"]
  },
  {
    "id": "length-of-last-word",
    "title": "Length of Last Word",
    "difficulty": "Easy",
    "description": "Given a string `s` consisting of words and spaces, return the length of the last word in the string.\n\nA word is a maximal substring consisting of non-space characters only.",
    "examples": [
      {
        "input": "s = \"Hello World\"",
        "output": "5",
        "explanation": "The last word is \"World\" with length 5."
      },
      {
        "input": "s = \"   fly me   to   the moon  \"",
        "output": "4",
        "explanation": "The last word is \"moon\" with length 4."
      },
      {
        "input": "s = \"luffy is still joyboy\"",
        "output": "6",
        "explanation": "The last word is \"joyboy\" with length 6."
      }
    ],
    "functionSignature": "def lengthOfLastWord(s: str) -> int:",
    "starterCode": "def lengthOfLastWord(s: str) -> int:\n    # Write your solution here\n    pass",
    "tags": ["Strings"]
  },
  {
    "id": "search-insert-position",
    "title": "Search Insert Position",
    "difficulty": "Easy",
    "description": "Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n\nYou must write an algorithm with O(log n) runtime complexity.",
    "examples": [
      {
        "input": "nums = [1,3,5,6], target = 5",
        "output": "2",
        "explanation": null
      },
      {
        "input": "nums = [1,3,5,6], target = 2",
        "output": "1",
        "explanation": null
      },
      {
        "input": "nums = [1,3,5,6], target = 7",
        "output": "4",
        "explanation": null
      }
    ],
    "functionSignature": "def searchInsert(nums: list[int], target: int) -> int:",
    "starterCode": "def searchInsert(nums: list[int], target: int) -> int:\n    # Write your solution here\n    pass",
    "tags": ["Binary Search", "Arrays"]
  },
  {
    "id": "single-number",
    "title": "Single Number",
    "difficulty": "Easy",
    "description": "Given a non-empty array of integers `nums`, every element appears twice except for one. Find that single one.\n\nYou must implement a solution with linear runtime complexity and use only constant extra space.",
    "examples": [
      {
        "input": "nums = [2,2,1]",
        "output": "1",
        "explanation": null
      },
      {
        "input": "nums = [4,1,2,1,2]",
        "output": "4",
        "explanation": null
      },
      {
        "input": "nums = [1]",
        "output": "1",
        "explanation": null
      }
    ],
    "functionSignature": "def singleNumber(nums: list[int]) -> int:",
    "starterCode": "def singleNumber(nums: list[int]) -> int:\n    # Write your solution here\n    pass",
    "tags": ["Arrays", "Bit Manipulation"]
  },
  {
    "id": "missing-number",
    "title": "Missing Number",
    "difficulty": "Easy",
    "description": "Given an array `nums` containing `n` distinct numbers in the range `[0, n]`, return the only number in the range that is missing from the array.",
    "examples": [
      {
        "input": "nums = [3,0,1]",
        "output": "2",
        "explanation": "n = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is missing."
      },
      {
        "input": "nums = [0,1]",
        "output": "2",
        "explanation": "n = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is missing."
      },
      {
        "input": "nums = [9,6,4,2,3,5,7,0,1]",
        "output": "8",
        "explanation": null
      }
    ],
    "functionSignature": "def missingNumber(nums: list[int]) -> int:",
    "starterCode": "def missingNumber(nums: list[int]) -> int:\n    # Write your solution here\n    pass",
    "tags": ["Arrays", "Math"]
  },
  {
    "id": "ransom-note",
    "title": "Ransom Note",
    "difficulty": "Easy",
    "description": "Given two strings `ransomNote` and `magazine`, return `true` if `ransomNote` can be constructed by using the letters from `magazine` and `false` otherwise.\n\nEach letter in `magazine` can only be used once in `ransomNote`.",
    "examples": [
      {
        "input": "ransomNote = \"a\", magazine = \"b\"",
        "output": "false",
        "explanation": null
      },
      {
        "input": "ransomNote = \"aa\", magazine = \"ab\"",
        "output": "false",
        "explanation": null
      },
      {
        "input": "ransomNote = \"aa\", magazine = \"aab\"",
        "output": "true",
        "explanation": null
      }
    ],
    "functionSignature": "def canConstruct(ransomNote: str, magazine: str) -> bool:",
    "starterCode": "def canConstruct(ransomNote: str, magazine: str) -> bool:\n    # Write your solution here\n    pass",
    "tags": ["Hash Map", "Strings"]
  },
  {
    "id": "isomorphic-strings",
    "title": "Isomorphic Strings",
    "difficulty": "Easy",
    "description": "Given two strings `s` and `t`, determine if they are isomorphic.\n\nTwo strings are isomorphic if the characters in `s` can be replaced to get `t`. All occurrences of a character must be replaced with another character while preserving the order. No two characters may map to the same character, but a character may map to itself.",
    "examples": [
      {
        "input": "s = \"egg\", t = \"add\"",
        "output": "true",
        "explanation": null
      },
      {
        "input": "s = \"foo\", t = \"bar\"",
        "output": "false",
        "explanation": null
      },
      {
        "input": "s = \"paper\", t = \"title\"",
        "output": "true",
        "explanation": null
      }
    ],
    "functionSignature": "def isIsomorphic(s: str, t: str) -> bool:",
    "starterCode": "def isIsomorphic(s: str, t: str) -> bool:\n    # Write your solution here\n    pass",
    "tags": ["Hash Map", "Strings"]
  },
  {
    "id": "best-time-to-buy-sell-stock",
    "title": "Best Time to Buy and Sell Stock",
    "difficulty": "Easy",
    "description": "You are given an array `prices` where `prices[i]` is the price of a given stock on the ith day.\n\nYou want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\n\nReturn the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.",
    "examples": [
      {
        "input": "prices = [7,1,5,3,6,4]",
        "output": "5",
        "explanation": "Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5."
      },
      {
        "input": "prices = [7,6,4,3,1]",
        "output": "0",
        "explanation": "No profitable transaction is possible."
      }
    ],
    "functionSignature": "def maxProfit(prices: list[int]) -> int:",
    "starterCode": "def maxProfit(prices: list[int]) -> int:\n    # Write your solution here\n    pass",
    "tags": ["Arrays", "Greedy"]
  },
  {
    "id": "move-zeroes",
    "title": "Move Zeroes",
    "difficulty": "Easy",
    "description": "Given an integer array `nums`, move all 0's to the end of it while maintaining the relative order of the non-zero elements.\n\nNote that you must do this in-place without making a copy of the array. Return the modified array.",
    "examples": [
      {
        "input": "nums = [0,1,0,3,12]",
        "output": "[1,3,12,0,0]",
        "explanation": null
      },
      {
        "input": "nums = [0]",
        "output": "[0]",
        "explanation": null
      }
    ],
    "functionSignature": "def moveZeroes(nums: list[int]) -> list[int]:",
    "starterCode": "def moveZeroes(nums: list[int]) -> list[int]:\n    # Modify nums in-place and return it\n    pass",
    "tags": ["Arrays", "Two Pointers"]
  },
  {
    "id": "plus-one",
    "title": "Plus One",
    "difficulty": "Easy",
    "description": "You are given a large integer represented as an integer array `digits`, where each `digits[i]` is the ith digit of the integer. The digits are ordered from most significant to least significant.\n\nIncrement the large integer by one and return the resulting array of digits.",
    "examples": [
      {
        "input": "digits = [1,2,3]",
        "output": "[1,2,4]",
        "explanation": "The array represents the integer 123. 123 + 1 = 124."
      },
      {
        "input": "digits = [4,3,2,1]",
        "output": "[4,3,2,2]",
        "explanation": null
      },
      {
        "input": "digits = [9]",
        "output": "[1,0]",
        "explanation": null
      }
    ],
    "functionSignature": "def plusOne(digits: list[int]) -> list[int]:",
    "starterCode": "def plusOne(digits: list[int]) -> list[int]:\n    # Write your solution here\n    pass",
    "tags": ["Arrays", "Math"]
  },
  {
    "id": "max-subarray",
    "title": "Maximum Subarray",
    "difficulty": "Medium",
    "description": "Given an integer array `nums`, find the subarray with the largest sum, and return its sum.\n\nA subarray is a contiguous non-empty sequence of elements within an array.",
    "examples": [
      {
        "input": "nums = [-2,1,-3,4,-1,2,1,-5,4]",
        "output": "6",
        "explanation": "The subarray [4,-1,2,1] has the largest sum 6."
      },
      {
        "input": "nums = [1]",
        "output": "1",
        "explanation": "The subarray [1] has the largest sum 1."
      },
      {
        "input": "nums = [5,4,-1,7,8]",
        "output": "23",
        "explanation": "The subarray [5,4,-1,7,8] has the largest sum 23."
      }
    ],
    "functionSignature": "def maxSubArray(nums: list[int]) -> int:",
    "starterCode": "def maxSubArray(nums: list[int]) -> int:\n    # Write your solution here\n    pass",
    "tags": ["Arrays", "Dynamic Programming"]
  },
  {
    "id": "valid-parentheses",
    "title": "Valid Parentheses",
    "difficulty": "Medium",
    "description": "Given a string `s` containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\n\nAn input string is valid if:\n1. Open brackets must be closed by the same type of brackets.\n2. Open brackets must be closed in the correct order.\n3. Every close bracket has a corresponding open bracket of the same type.",
    "examples": [
      {
        "input": "s = \"()\"",
        "output": "true",
        "explanation": null
      },
      {
        "input": "s = \"()[]{}\"",
        "output": "true",
        "explanation": null
      },
      {
        "input": "s = \"(]\"",
        "output": "false",
        "explanation": null
      }
    ],
    "functionSignature": "def isValid(s: str) -> bool:",
    "starterCode": "def isValid(s: str) -> bool:\n    # Write your solution here\n    pass",
    "tags": ["Stack", "Strings"]
  },
  {
    "id": "merge-sorted-lists",
    "title": "Merge Two Sorted Lists",
    "difficulty": "Medium",
    "description": "You are given two sorted integer arrays `list1` and `list2`. Merge them into a single sorted array and return it.\n\nThe resulting array should be made by splicing together the values from the two input arrays in sorted order.",
    "examples": [
      {
        "input": "list1 = [1,2,4], list2 = [1,3,4]",
        "output": "[1,1,2,3,4,4]",
        "explanation": null
      },
      {
        "input": "list1 = [], list2 = []",
        "output": "[]",
        "explanation": null
      },
      {
        "input": "list1 = [], list2 = [0]",
        "output": "[0]",
        "explanation": null
      }
    ],
    "functionSignature": "def mergeTwoLists(list1: list[int], list2: list[int]) -> list[int]:",
    "starterCode": "def mergeTwoLists(list1: list[int], list2: list[int]) -> list[int]:\n    # Write your solution here\n    pass",
    "tags": ["Arrays", "Sorting"]
  },
  {
    "id": "group-anagrams",
    "title": "Group Anagrams",
    "difficulty": "Medium",
    "description": "Given an array of strings `strs`, group the anagrams together. You can return the answer in any order.\n\nAn anagram is a word formed by rearranging the letters of another word, using all the original letters exactly once.",
    "examples": [
      {
        "input": "strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]",
        "output": "[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]",
        "explanation": null
      },
      {
        "input": "strs = [\"\"]",
        "output": "[[\"\"]]",
        "explanation": null
      },
      {
        "input": "strs = [\"a\"]",
        "output": "[[\"a\"]]",
        "explanation": null
      }
    ],
    "functionSignature": "def groupAnagrams(strs: list[str]) -> list[list[str]]:",
    "starterCode": "def groupAnagrams(strs: list[str]) -> list[list[str]]:\n    # Write your solution here\n    pass",
    "tags": ["Hash Map", "Strings", "Sorting"]
  },
  {
    "id": "product-except-self",
    "title": "Product of Array Except Self",
    "difficulty": "Medium",
    "description": "Given an integer array `nums`, return an array `answer` such that `answer[i]` is equal to the product of all the elements of `nums` except `nums[i]`.\n\nYou must write an algorithm that runs in O(n) time and without using the division operation.",
    "examples": [
      {
        "input": "nums = [1,2,3,4]",
        "output": "[24,12,8,6]",
        "explanation": null
      },
      {
        "input": "nums = [-1,1,0,-3,3]",
        "output": "[0,0,9,0,0]",
        "explanation": null
      }
    ],
    "functionSignature": "def productExceptSelf(nums: list[int]) -> list[int]:",
    "starterCode": "def productExceptSelf(nums: list[int]) -> list[int]:\n    # Write your solution here\n    pass",
    "tags": ["Arrays"]
  },
  {
    "id": "container-with-most-water",
    "title": "Container With Most Water",
    "difficulty": "Medium",
    "description": "You are given an integer array `height` of length `n`. There are `n` vertical lines drawn such that the two endpoints of the ith line are `(i, 0)` and `(i, height[i])`.\n\nFind two lines that together with the x-axis form a container, such that the container contains the most water.\n\nReturn the maximum amount of water a container can store.",
    "examples": [
      {
        "input": "height = [1,8,6,2,5,4,8,3,7]",
        "output": "49",
        "explanation": "Lines at index 1 and 8 form a container with area 49."
      },
      {
        "input": "height = [1,1]",
        "output": "1",
        "explanation": null
      }
    ],
    "functionSignature": "def maxArea(height: list[int]) -> int:",
    "starterCode": "def maxArea(height: list[int]) -> int:\n    # Write your solution here\n    pass",
    "tags": ["Two Pointers", "Greedy"]
  },
  {
    "id": "three-sum",
    "title": "3Sum",
    "difficulty": "Medium",
    "description": "Given an integer array `nums`, return all the triplets `[nums[i], nums[j], nums[k]]` such that `i != j`, `i != k`, and `j != k`, and `nums[i] + nums[j] + nums[k] == 0`.\n\nNotice that the solution set must not contain duplicate triplets.",
    "examples": [
      {
        "input": "nums = [-1,0,1,2,-1,-4]",
        "output": "[[-1,-1,2],[-1,0,1]]",
        "explanation": null
      },
      {
        "input": "nums = [0,1,1]",
        "output": "[]",
        "explanation": null
      },
      {
        "input": "nums = [0,0,0]",
        "output": "[[0,0,0]]",
        "explanation": null
      }
    ],
    "functionSignature": "def threeSum(nums: list[int]) -> list[list[int]]:",
    "starterCode": "def threeSum(nums: list[int]) -> list[list[int]]:\n    # Write your solution here\n    pass",
    "tags": ["Arrays", "Two Pointers", "Sorting"]
  },
  {
    "id": "house-robber",
    "title": "House Robber",
    "difficulty": "Medium",
    "description": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. Adjacent houses have security systems connected — if two adjacent houses were broken into on the same night, the police will be contacted.\n\nGiven an integer array `nums` representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.",
    "examples": [
      {
        "input": "nums = [1,2,3,1]",
        "output": "4",
        "explanation": "Rob house 1 (money = 1) and then rob house 3 (money = 3). Total = 1 + 3 = 4."
      },
      {
        "input": "nums = [2,7,9,3,1]",
        "output": "12",
        "explanation": "Rob house 1 (money = 2), house 3 (money = 9), and house 5 (money = 1). Total = 12."
      }
    ],
    "functionSignature": "def rob(nums: list[int]) -> int:",
    "starterCode": "def rob(nums: list[int]) -> int:\n    # Write your solution here\n    pass",
    "tags": ["Dynamic Programming", "Arrays"]
  },
  {
    "id": "coin-change",
    "title": "Coin Change",
    "difficulty": "Medium",
    "description": "You are given an integer array `coins` representing coins of different denominations and an integer `amount` representing a total amount of money.\n\nReturn the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.\n\nYou may assume that you have an infinite number of each kind of coin.",
    "examples": [
      {
        "input": "coins = [1,5,10], amount = 12",
        "output": "3",
        "explanation": "12 = 10 + 1 + 1"
      },
      {
        "input": "coins = [2], amount = 3",
        "output": "-1",
        "explanation": null
      },
      {
        "input": "coins = [1], amount = 0",
        "output": "0",
        "explanation": null
      }
    ],
    "functionSignature": "def coinChange(coins: list[int], amount: int) -> int:",
    "starterCode": "def coinChange(coins: list[int], amount: int) -> int:\n    # Write your solution here\n    pass",
    "tags": ["Dynamic Programming"]
  },
  {
    "id": "unique-paths",
    "title": "Unique Paths",
    "difficulty": "Medium",
    "description": "There is a robot on an `m x n` grid. The robot is initially located at the top-left corner. The robot tries to move to the bottom-right corner. The robot can only move either down or right at any point in time.\n\nGiven the two integers `m` and `n`, return the number of possible unique paths that the robot can take to reach the bottom-right corner.",
    "examples": [
      {
        "input": "m = 3, n = 7",
        "output": "28",
        "explanation": null
      },
      {
        "input": "m = 3, n = 2",
        "output": "3",
        "explanation": "Right+Down+Down, Down+Right+Down, Down+Down+Right."
      }
    ],
    "functionSignature": "def uniquePaths(m: int, n: int) -> int:",
    "starterCode": "def uniquePaths(m: int, n: int) -> int:\n    # Write your solution here\n    pass",
    "tags": ["Dynamic Programming", "Math"]
  },
  {
    "id": "jump-game",
    "title": "Jump Game",
    "difficulty": "Medium",
    "description": "You are given an integer array `nums`. You are initially positioned at the array's first index, and each element in the array represents your maximum jump length at that position.\n\nReturn `true` if you can reach the last index, or `false` otherwise.",
    "examples": [
      {
        "input": "nums = [2,3,1,1,4]",
        "output": "true",
        "explanation": "Jump 1 step from index 0 to 1, then 3 steps to the last index."
      },
      {
        "input": "nums = [3,2,1,0,4]",
        "output": "false",
        "explanation": "You will always arrive at index 3 no matter what. Its maximum jump length is 0."
      }
    ],
    "functionSignature": "def canJump(nums: list[int]) -> bool:",
    "starterCode": "def canJump(nums: list[int]) -> bool:\n    # Write your solution here\n    pass",
    "tags": ["Greedy", "Arrays"]
  },
  {
    "id": "sort-colors",
    "title": "Sort Colors",
    "difficulty": "Medium",
    "description": "Given an array `nums` with `n` objects colored red (0), white (1), or blue (2), sort them in-place so that objects of the same color are adjacent, in the order red, white, and blue.\n\nYou must solve this problem without using the library's sort function. Return the sorted array.",
    "examples": [
      {
        "input": "nums = [2,0,2,1,1,0]",
        "output": "[0,0,1,1,2,2]",
        "explanation": null
      },
      {
        "input": "nums = [2,0,1]",
        "output": "[0,1,2]",
        "explanation": null
      }
    ],
    "functionSignature": "def sortColors(nums: list[int]) -> list[int]:",
    "starterCode": "def sortColors(nums: list[int]) -> list[int]:\n    # Sort in-place and return nums\n    pass",
    "tags": ["Arrays", "Two Pointers", "Sorting"]
  },
  {
    "id": "min-stack",
    "title": "Min Stack",
    "difficulty": "Medium",
    "description": "Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.\n\nImplement the `MinStack` class:\n- `push(val)` pushes the element val onto the stack.\n- `pop()` removes the element on the top of the stack.\n- `top()` gets the top element of the stack.\n- `getMin()` retrieves the minimum element in the stack.\n\nThe function receives a list of operations and a list of arguments, and should return a list of results (None for push/pop).",
    "examples": [
      {
        "input": "ops = [\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"], args = [[-2],[0],[-3],[],[],[],[]]",
        "output": "[None,None,None,-3,None,0,-2]",
        "explanation": null
      }
    ],
    "functionSignature": "def minStack(operations: list[str], arguments: list[list]) -> list:",
    "starterCode": "def minStack(operations: list, arguments: list) -> list:\n    # Implement MinStack and process operations\n    pass",
    "tags": ["Stack", "Design"]
  },
  {
    "id": "search-rotated-array",
    "title": "Search in Rotated Sorted Array",
    "difficulty": "Medium",
    "description": "There is an integer array `nums` sorted in ascending order (with distinct values). Prior to being passed to your function, `nums` is possibly rotated at an unknown pivot index.\n\nGiven the array `nums` after the possible rotation and an integer `target`, return the index of `target` if it is in `nums`, or -1 if it is not.\n\nYou must write an algorithm with O(log n) runtime complexity.",
    "examples": [
      {
        "input": "nums = [4,5,6,7,0,1,2], target = 0",
        "output": "4",
        "explanation": null
      },
      {
        "input": "nums = [4,5,6,7,0,1,2], target = 3",
        "output": "-1",
        "explanation": null
      },
      {
        "input": "nums = [1], target = 0",
        "output": "-1",
        "explanation": null
      }
    ],
    "functionSignature": "def search(nums: list[int], target: int) -> int:",
    "starterCode": "def search(nums: list[int], target: int) -> int:\n    # Write your solution here\n    pass",
    "tags": ["Binary Search", "Arrays"]
  },
  {
    "id": "merge-intervals",
    "title": "Merge Intervals",
    "difficulty": "Medium",
    "description": "Given an array of `intervals` where `intervals[i] = [start_i, end_i]`, merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.",
    "examples": [
      {
        "input": "intervals = [[1,3],[2,6],[8,10],[15,18]]",
        "output": "[[1,6],[8,10],[15,18]]",
        "explanation": "Since intervals [1,3] and [2,6] overlap, merge them into [1,6]."
      },
      {
        "input": "intervals = [[1,4],[4,5]]",
        "output": "[[1,5]]",
        "explanation": "Intervals [1,4] and [4,5] are considered overlapping."
      }
    ],
    "functionSignature": "def merge(intervals: list[list[int]]) -> list[list[int]]:",
    "starterCode": "def merge(intervals: list[list[int]]) -> list[list[int]]:\n    # Write your solution here\n    pass",
    "tags": ["Arrays", "Sorting"]
  },
  {
    "id": "remove-duplicates-sorted",
    "title": "Remove Duplicates from Sorted Array",
    "difficulty": "Medium",
    "description": "Given an integer array `nums` sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same.\n\nReturn the number of unique elements in `nums`.",
    "examples": [
      {
        "input": "nums = [1,1,2]",
        "output": "2",
        "explanation": "Your function should return k = 2, with the first two elements of nums being 1 and 2."
      },
      {
        "input": "nums = [0,0,1,1,1,2,2,3,3,4]",
        "output": "5",
        "explanation": "Your function should return k = 5, with the first five elements being 0, 1, 2, 3, and 4."
      }
    ],
    "functionSignature": "def removeDuplicates(nums: list[int]) -> int:",
    "starterCode": "def removeDuplicates(nums: list[int]) -> int:\n    # Write your solution here\n    pass",
    "tags": ["Arrays", "Two Pointers"]
  },
  {
    "id": "longest-substring-no-repeat",
    "title": "Longest Substring Without Repeating Characters",
    "difficulty": "Medium",
    "description": "Given a string `s`, find the length of the longest substring without repeating characters.",
    "examples": [
      {
        "input": "s = \"abcabcbb\"",
        "output": "3",
        "explanation": "The answer is \"abc\", with the length of 3."
      },
      {
        "input": "s = \"bbbbb\"",
        "output": "1",
        "explanation": "The answer is \"b\", with the length of 1."
      },
      {
        "input": "s = \"pwwkew\"",
        "output": "3",
        "explanation": "The answer is \"wke\", with the length of 3."
      }
    ],
    "functionSignature": "def lengthOfLongestSubstring(s: str) -> int:",
    "starterCode": "def lengthOfLongestSubstring(s: str) -> int:\n    # Write your solution here\n    pass",
    "tags": ["Strings", "Sliding Window", "Hash Map"]
  },
  {
    "id": "best-time-buy-sell-stock-ii",
    "title": "Best Time to Buy and Sell Stock II",
    "difficulty": "Medium",
    "description": "You are given an integer array `prices` where `prices[i]` is the price of a given stock on the ith day.\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\n\nFind and return the maximum profit you can achieve.",
    "examples": [
      {
        "input": "prices = [7,1,5,3,6,4]",
        "output": "7",
        "explanation": "Buy on day 2 (price=1), sell day 3 (price=5), profit=4. Then buy day 4 (price=3), sell day 5 (price=6), profit=3. Total=7."
      },
      {
        "input": "prices = [1,2,3,4,5]",
        "output": "4",
        "explanation": "Buy on day 1 (price=1), sell on day 5 (price=5), profit=4."
      },
      {
        "input": "prices = [7,6,4,3,1]",
        "output": "0",
        "explanation": "No profitable transaction possible."
      }
    ],
    "functionSignature": "def maxProfitII(prices: list[int]) -> int:",
    "starterCode": "def maxProfitII(prices: list[int]) -> int:\n    # Write your solution here\n    pass",
    "tags": ["Greedy", "Arrays"]
  },
  {
    "id": "rotate-array",
    "title": "Rotate Array",
    "difficulty": "Medium",
    "description": "Given an integer array `nums`, rotate the array to the right by `k` steps, where `k` is non-negative. Return the rotated array.",
    "examples": [
      {
        "input": "nums = [1,2,3,4,5,6,7], k = 3",
        "output": "[5,6,7,1,2,3,4]",
        "explanation": "Rotate 1 step: [7,1,2,3,4,5,6]. Rotate 2 steps: [6,7,1,2,3,4,5]. Rotate 3 steps: [5,6,7,1,2,3,4]."
      },
      {
        "input": "nums = [-1,-100,3,99], k = 2",
        "output": "[3,99,-1,-100]",
        "explanation": null
      }
    ],
    "functionSignature": "def rotate(nums: list[int], k: int) -> list[int]:",
    "starterCode": "def rotate(nums: list[int], k: int) -> list[int]:\n    # Rotate in-place and return nums\n    pass",
    "tags": ["Arrays", "Math"]
  },
  {
    "id": "pow-x-n",
    "title": "Pow(x, n)",
    "difficulty": "Medium",
    "description": "Implement `pow(x, n)`, which calculates `x` raised to the power `n` (i.e., x^n).",
    "examples": [
      {
        "input": "x = 2.0, n = 10",
        "output": "1024.0",
        "explanation": null
      },
      {
        "input": "x = 2.1, n = 3",
        "output": "9.261",
        "explanation": null
      },
      {
        "input": "x = 2.0, n = -2",
        "output": "0.25",
        "explanation": "2^-2 = 1/(2^2) = 1/4 = 0.25"
      }
    ],
    "functionSignature": "def myPow(x: float, n: int) -> float:",
    "starterCode": "def myPow(x: float, n: int) -> float:\n    # Write your solution here\n    pass",
    "tags": ["Math", "Recursion"]
  },
  {
    "id": "spiral-matrix",
    "title": "Spiral Matrix",
    "difficulty": "Hard",
    "description": "Given an `m x n` matrix, return all elements of the matrix in spiral order.",
    "examples": [
      {
        "input": "matrix = [[1,2,3],[4,5,6],[7,8,9]]",
        "output": "[1,2,3,6,9,8,7,4,5]",
        "explanation": null
      },
      {
        "input": "matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]",
        "output": "[1,2,3,4,8,12,11,10,9,5,6,7]",
        "explanation": null
      }
    ],
    "functionSignature": "def spiralOrder(matrix: list[list[int]]) -> list[int]:",
    "starterCode": "def spiralOrder(matrix: list[list[int]]) -> list[int]:\n    # Write your solution here\n    pass",
    "tags": ["Arrays", "Matrix"]
  },
  {
    "id": "word-search",
    "title": "Word Search",
    "difficulty": "Hard",
    "description": "Given an `m x n` grid of characters `board` and a string `word`, return `true` if `word` exists in the grid.\n\nThe word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.",
    "examples": [
      {
        "input": "board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCCED\"",
        "output": "true",
        "explanation": null
      },
      {
        "input": "board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"SEE\"",
        "output": "true",
        "explanation": null
      },
      {
        "input": "board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCB\"",
        "output": "false",
        "explanation": null
      }
    ],
    "functionSignature": "def exist(board: list[list[str]], word: str) -> bool:",
    "starterCode": "def exist(board: list[list[str]], word: str) -> bool:\n    # Write your solution here\n    pass",
    "tags": ["Arrays", "Backtracking", "Matrix"]
  },
  {
    "id": "trapping-rain-water",
    "title": "Trapping Rain Water",
    "difficulty": "Hard",
    "description": "Given `n` non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.",
    "examples": [
      {
        "input": "height = [0,1,0,2,1,0,1,3,2,1,2,1]",
        "output": "6",
        "explanation": "6 units of rain water are trapped."
      },
      {
        "input": "height = [4,2,0,3,2,5]",
        "output": "9",
        "explanation": null
      }
    ],
    "functionSignature": "def trap(height: list[int]) -> int:",
    "starterCode": "def trap(height: list[int]) -> int:\n    # Write your solution here\n    pass",
    "tags": ["Arrays", "Two Pointers", "Dynamic Programming"]
  },
  {
    "id": "longest-palindromic-substring",
    "title": "Longest Palindromic Substring",
    "difficulty": "Hard",
    "description": "Given a string `s`, return the longest palindromic substring in `s`.",
    "examples": [
      {
        "input": "s = \"babad\"",
        "output": "\"bab\"",
        "explanation": "\"aba\" is also a valid answer."
      },
      {
        "input": "s = \"cbbd\"",
        "output": "\"bb\"",
        "explanation": null
      }
    ],
    "functionSignature": "def longestPalindrome(s: str) -> str:",
    "starterCode": "def longestPalindrome(s: str) -> str:\n    # Write your solution here\n    pass",
    "tags": ["Strings", "Dynamic Programming"]
  },
  {
    "id": "majority-element",
    "title": "Majority Element",
    "difficulty": "Easy",
    "description": "Given an array `nums` of size `n`, return the majority element.\n\nThe majority element is the element that appears more than n/2 times. You may assume that the majority element always exists in the array.",
    "examples": [
      {
        "input": "nums = [3,2,3]",
        "output": "3",
        "explanation": null
      },
      {
        "input": "nums = [2,2,1,1,1,2,2]",
        "output": "2",
        "explanation": null
      }
    ],
    "functionSignature": "def majorityElement(nums: list[int]) -> int:",
    "starterCode": "def majorityElement(nums: list[int]) -> int:\n    # Write your solution here\n    pass",
    "tags": ["Arrays", "Hash Map"]
  },
  {
    "id": "happy-number",
    "title": "Happy Number",
    "difficulty": "Easy",
    "description": "Write an algorithm to determine if a number `n` is happy.\n\nA happy number is defined by replacing the number by the sum of the squares of its digits, and repeating until the number equals 1 (where it stays), or it loops endlessly in a cycle which does not include 1.\n\nReturn `true` if `n` is a happy number, `false` otherwise.",
    "examples": [
      {
        "input": "n = 19",
        "output": "true",
        "explanation": "1² + 9² = 82, 8² + 2² = 68, 6² + 8² = 100, 1² + 0² + 0² = 1."
      },
      {
        "input": "n = 2",
        "output": "false",
        "explanation": null
      }
    ],
    "functionSignature": "def isHappy(n: int) -> bool:",
    "starterCode": "def isHappy(n: int) -> bool:\n    # Write your solution here\n    pass",
    "tags": ["Math", "Hash Map"]
  },
  {
    "id": "power-of-three",
    "title": "Power of Three",
    "difficulty": "Easy",
    "description": "Given an integer `n`, return `true` if it is a power of three. Otherwise, return `false`.\n\nAn integer `n` is a power of three, if there exists an integer `x` such that n == 3^x.",
    "examples": [
      {
        "input": "n = 27",
        "output": "true",
        "explanation": "27 = 3³"
      },
      {
        "input": "n = 0",
        "output": "false",
        "explanation": null
      },
      {
        "input": "n = -1",
        "output": "false",
        "explanation": null
      }
    ],
    "functionSignature": "def isPowerOfThree(n: int) -> bool:",
    "starterCode": "def isPowerOfThree(n: int) -> bool:\n    # Write your solution here\n    pass",
    "tags": ["Math"]
  },
  {
    "id": "merge-sorted-array",
    "title": "Merge Sorted Array",
    "difficulty": "Easy",
    "description": "You are given two integer arrays `nums1` and `nums2`, sorted in non-decreasing order, and two integers `m` and `n`, representing the number of elements in `nums1` and `nums2` respectively.\n\nMerge `nums2` into `nums1` as one sorted array. The final sorted array should not be returned by the function, but instead be stored inside the array `nums1`. `nums1` has a length of `m + n`, where the last `n` elements are set to 0 and should be ignored.\n\nReturn the merged array.",
    "examples": [
      {
        "input": "nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3",
        "output": "[1,2,2,3,5,6]",
        "explanation": null
      },
      {
        "input": "nums1 = [1], m = 1, nums2 = [], n = 0",
        "output": "[1]",
        "explanation": null
      }
    ],
    "functionSignature": "def mergeSortedArray(nums1: list[int], m: int, nums2: list[int], n: int) -> list[int]:",
    "starterCode": "def mergeSortedArray(nums1: list[int], m: int, nums2: list[int], n: int) -> list[int]:\n    # Merge in-place and return nums1\n    pass",
    "tags": ["Arrays", "Two Pointers", "Sorting"]
  },
  {
    "id": "remove-element",
    "title": "Remove Element",
    "difficulty": "Easy",
    "description": "Given an integer array `nums` and an integer `val`, remove all occurrences of `val` in `nums` in-place. The order of the elements may be changed.\n\nReturn the number of elements in `nums` which are not equal to `val`.",
    "examples": [
      {
        "input": "nums = [3,2,2,3], val = 3",
        "output": "2",
        "explanation": "Your function should return k = 2, with the first two elements of nums being 2 and 2."
      },
      {
        "input": "nums = [0,1,2,2,3,0,4,2], val = 2",
        "output": "5",
        "explanation": "Your function should return k = 5, with the first five elements being 0, 1, 3, 0, and 4."
      }
    ],
    "functionSignature": "def removeElement(nums: list[int], val: int) -> int:",
    "starterCode": "def removeElement(nums: list[int], val: int) -> int:\n    # Write your solution here\n    pass",
    "tags": ["Arrays", "Two Pointers"]
  },
  {
    "id": "excel-column-number",
    "title": "Excel Sheet Column Number",
    "difficulty": "Easy",
    "description": "Given a string `columnTitle` that represents the column title as appears in an Excel sheet, return its corresponding column number.\n\nFor example: A -> 1, B -> 2, ..., Z -> 26, AA -> 27, AB -> 28, ...",
    "examples": [
      {
        "input": "columnTitle = \"A\"",
        "output": "1",
        "explanation": null
      },
      {
        "input": "columnTitle = \"AB\"",
        "output": "28",
        "explanation": null
      },
      {
        "input": "columnTitle = \"ZY\"",
        "output": "701",
        "explanation": null
      }
    ],
    "functionSignature": "def titleToNumber(columnTitle: str) -> int:",
    "starterCode": "def titleToNumber(columnTitle: str) -> int:\n    # Write your solution here\n    pass",
    "tags": ["Math", "Strings"]
  },
  {
    "id": "intersection-two-arrays",
    "title": "Intersection of Two Arrays II",
    "difficulty": "Easy",
    "description": "Given two integer arrays `nums1` and `nums2`, return an array of their intersection. Each element in the result must appear as many times as it shows in both arrays. You may return the result in any order.",
    "examples": [
      {
        "input": "nums1 = [1,2,2,1], nums2 = [2,2]",
        "output": "[2,2]",
        "explanation": null
      },
      {
        "input": "nums1 = [4,9,5], nums2 = [9,4,9,8,4]",
        "output": "[4,9]",
        "explanation": "or [9,4] is also accepted."
      }
    ],
    "functionSignature": "def intersect(nums1: list[int], nums2: list[int]) -> list[int]:",
    "starterCode": "def intersect(nums1: list[int], nums2: list[int]) -> list[int]:\n    # Write your solution here\n    pass",
    "tags": ["Arrays", "Hash Map", "Sorting"]
  },
  {
    "id": "add-binary",
    "title": "Add Binary",
    "difficulty": "Easy",
    "description": "Given two binary strings `a` and `b`, return their sum as a binary string.",
    "examples": [
      {
        "input": "a = \"11\", b = \"1\"",
        "output": "\"100\"",
        "explanation": null
      },
      {
        "input": "a = \"1010\", b = \"1011\"",
        "output": "\"10101\"",
        "explanation": null
      }
    ],
    "functionSignature": "def addBinary(a: str, b: str) -> str:",
    "starterCode": "def addBinary(a: str, b: str) -> str:\n    # Write your solution here\n    pass",
    "tags": ["Math", "Strings", "Bit Manipulation"]
  },
  {
    "id": "sqrt-x",
    "title": "Sqrt(x)",
    "difficulty": "Easy",
    "description": "Given a non-negative integer `x`, return the square root of `x` rounded down to the nearest integer. The returned integer should be non-negative as well.\n\nYou must not use any built-in exponent function or operator (like `**` or `pow`).",
    "examples": [
      {
        "input": "x = 4",
        "output": "2",
        "explanation": null
      },
      {
        "input": "x = 8",
        "output": "2",
        "explanation": "The square root of 8 is 2.828..., rounded down to 2."
      }
    ],
    "functionSignature": "def mySqrt(x: int) -> int:",
    "starterCode": "def mySqrt(x: int) -> int:\n    # Write your solution here (without using ** or pow)\n    pass",
    "tags": ["Binary Search", "Math"]
  },
  {
    "id": "top-k-frequent",
    "title": "Top K Frequent Elements",
    "difficulty": "Medium",
    "description": "Given an integer array `nums` and an integer `k`, return the `k` most frequent elements. You may return the answer in any order.",
    "examples": [
      {
        "input": "nums = [1,1,1,2,2,3], k = 2",
        "output": "[1,2]",
        "explanation": null
      },
      {
        "input": "nums = [1], k = 1",
        "output": "[1]",
        "explanation": null
      }
    ],
    "functionSignature": "def topKFrequent(nums: list[int], k: int) -> list[int]:",
    "starterCode": "def topKFrequent(nums: list[int], k: int) -> list[int]:\n    # Write your solution here\n    pass",
    "tags": ["Arrays", "Hash Map", "Sorting"]
  },
  {
    "id": "subsets",
    "title": "Subsets",
    "difficulty": "Medium",
    "description": "Given an integer array `nums` of unique elements, return all possible subsets (the power set).\n\nThe solution set must not contain duplicate subsets. Return the solution in any order.",
    "examples": [
      {
        "input": "nums = [1,2,3]",
        "output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
        "explanation": null
      },
      {
        "input": "nums = [0]",
        "output": "[[],[0]]",
        "explanation": null
      }
    ],
    "functionSignature": "def subsets(nums: list[int]) -> list[list[int]]:",
    "starterCode": "def subsets(nums: list[int]) -> list[list[int]]:\n    # Write your solution here\n    pass",
    "tags": ["Arrays", "Backtracking"]
  },
  {
    "id": "permutations",
    "title": "Permutations",
    "difficulty": "Medium",
    "description": "Given an array `nums` of distinct integers, return all the possible permutations. You can return the answer in any order.",
    "examples": [
      {
        "input": "nums = [1,2,3]",
        "output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
        "explanation": null
      },
      {
        "input": "nums = [0,1]",
        "output": "[[0,1],[1,0]]",
        "explanation": null
      },
      {
        "input": "nums = [1]",
        "output": "[[1]]",
        "explanation": null
      }
    ],
    "functionSignature": "def permute(nums: list[int]) -> list[list[int]]:",
    "starterCode": "def permute(nums: list[int]) -> list[list[int]]:\n    # Write your solution here\n    pass",
    "tags": ["Arrays", "Backtracking", "Recursion"]
  },
  {
    "id": "letter-combinations",
    "title": "Letter Combinations of a Phone Number",
    "difficulty": "Medium",
    "description": "Given a string containing digits from 2-9, return all possible letter combinations that the number could represent. Return the answer in any order.\n\nMapping: 2=abc, 3=def, 4=ghi, 5=jkl, 6=mno, 7=pqrs, 8=tuv, 9=wxyz",
    "examples": [
      {
        "input": "digits = \"23\"",
        "output": "[\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]",
        "explanation": null
      },
      {
        "input": "digits = \"\"",
        "output": "[]",
        "explanation": null
      },
      {
        "input": "digits = \"2\"",
        "output": "[\"a\",\"b\",\"c\"]",
        "explanation": null
      }
    ],
    "functionSignature": "def letterCombinations(digits: str) -> list[str]:",
    "starterCode": "def letterCombinations(digits: str) -> list[str]:\n    # Write your solution here\n    pass",
    "tags": ["Strings", "Backtracking", "Recursion"]
  },
  {
    "id": "generate-parentheses",
    "title": "Generate Parentheses",
    "difficulty": "Medium",
    "description": "Given `n` pairs of parentheses, write a function to generate all combinations of well-formed parentheses.",
    "examples": [
      {
        "input": "n = 3",
        "output": "[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]",
        "explanation": null
      },
      {
        "input": "n = 1",
        "output": "[\"()\"]",
        "explanation": null
      }
    ],
    "functionSignature": "def generateParenthesis(n: int) -> list[str]:",
    "starterCode": "def generateParenthesis(n: int) -> list[str]:\n    # Write your solution here\n    pass",
    "tags": ["Strings", "Backtracking", "Recursion"]
  },
  {
    "id": "set-matrix-zeroes",
    "title": "Set Matrix Zeroes",
    "difficulty": "Medium",
    "description": "Given an `m x n` integer matrix, if an element is 0, set its entire row and column to 0's.\n\nYou must do it in place. Return the modified matrix.",
    "examples": [
      {
        "input": "matrix = [[1,1,1],[1,0,1],[1,1,1]]",
        "output": "[[1,0,1],[0,0,0],[1,0,1]]",
        "explanation": null
      },
      {
        "input": "matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]",
        "output": "[[0,0,0,0],[0,4,5,0],[0,3,1,0]]",
        "explanation": null
      }
    ],
    "functionSignature": "def setZeroes(matrix: list[list[int]]) -> list[list[int]]:",
    "starterCode": "def setZeroes(matrix: list[list[int]]) -> list[list[int]]:\n    # Modify in-place and return matrix\n    pass",
    "tags": ["Arrays", "Matrix"]
  },
  {
    "id": "max-product-subarray",
    "title": "Maximum Product Subarray",
    "difficulty": "Medium",
    "description": "Given an integer array `nums`, find a subarray that has the largest product, and return the product.\n\nA subarray is a contiguous non-empty sequence of elements within an array.",
    "examples": [
      {
        "input": "nums = [2,3,-2,4]",
        "output": "6",
        "explanation": "[2,3] has the largest product 6."
      },
      {
        "input": "nums = [-2,0,-1]",
        "output": "0",
        "explanation": "The result cannot be 2, because [-2,-1] is not a subarray."
      }
    ],
    "functionSignature": "def maxProduct(nums: list[int]) -> int:",
    "starterCode": "def maxProduct(nums: list[int]) -> int:\n    # Write your solution here\n    pass",
    "tags": ["Arrays", "Dynamic Programming"]
  },
  {
    "id": "find-min-rotated",
    "title": "Find Minimum in Rotated Sorted Array",
    "difficulty": "Medium",
    "description": "Suppose an array of length `n` sorted in ascending order is rotated between 1 and `n` times. Given the sorted rotated array `nums` of unique elements, return the minimum element of this array.\n\nYou must write an algorithm that runs in O(log n) time.",
    "examples": [
      {
        "input": "nums = [3,4,5,1,2]",
        "output": "1",
        "explanation": "The original array was [1,2,3,4,5] rotated 3 times."
      },
      {
        "input": "nums = [4,5,6,7,0,1,2]",
        "output": "0",
        "explanation": null
      },
      {
        "input": "nums = [11,13,15,17]",
        "output": "11",
        "explanation": "The original array was not rotated."
      }
    ],
    "functionSignature": "def findMin(nums: list[int]) -> int:",
    "starterCode": "def findMin(nums: list[int]) -> int:\n    # Write your solution here\n    pass",
    "tags": ["Binary Search", "Arrays"]
  },
  {
    "id": "longest-increasing-subsequence",
    "title": "Longest Increasing Subsequence",
    "difficulty": "Medium",
    "description": "Given an integer array `nums`, return the length of the longest strictly increasing subsequence.",
    "examples": [
      {
        "input": "nums = [10,9,2,5,3,7,101,18]",
        "output": "4",
        "explanation": "The longest increasing subsequence is [2,3,7,101], length 4."
      },
      {
        "input": "nums = [0,1,0,3,2,3]",
        "output": "4",
        "explanation": null
      },
      {
        "input": "nums = [7,7,7,7,7,7,7]",
        "output": "1",
        "explanation": null
      }
    ],
    "functionSignature": "def lengthOfLIS(nums: list[int]) -> int:",
    "starterCode": "def lengthOfLIS(nums: list[int]) -> int:\n    # Write your solution here\n    pass",
    "tags": ["Arrays", "Dynamic Programming", "Binary Search"]
  },
  {
    "id": "word-break",
    "title": "Word Break",
    "difficulty": "Medium",
    "description": "Given a string `s` and a dictionary of strings `wordDict`, return `true` if `s` can be segmented into a space-separated sequence of one or more dictionary words.",
    "examples": [
      {
        "input": "s = \"leetcode\", wordDict = [\"leet\",\"code\"]",
        "output": "true",
        "explanation": "Return true because \"leetcode\" can be segmented as \"leet code\"."
      },
      {
        "input": "s = \"applepenapple\", wordDict = [\"apple\",\"pen\"]",
        "output": "true",
        "explanation": "Return true because \"applepenapple\" can be segmented as \"apple pen apple\"."
      },
      {
        "input": "s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]",
        "output": "false",
        "explanation": null
      }
    ],
    "functionSignature": "def wordBreak(s: str, wordDict: list[str]) -> bool:",
    "starterCode": "def wordBreak(s: str, wordDict: list[str]) -> bool:\n    # Write your solution here\n    pass",
    "tags": ["Strings", "Dynamic Programming"]
  },
  {
    "id": "decode-ways",
    "title": "Decode Ways",
    "difficulty": "Medium",
    "description": "A message containing letters A-Z can be encoded by mapping 'A' -> \"1\", 'B' -> \"2\", ..., 'Z' -> \"26\".\n\nGiven a string `s` containing only digits, return the number of ways to decode it. The answer is guaranteed to fit in a 32-bit integer.",
    "examples": [
      {
        "input": "s = \"12\"",
        "output": "2",
        "explanation": "\"12\" could be decoded as \"AB\" (1 2) or \"L\" (12)."
      },
      {
        "input": "s = \"226\"",
        "output": "3",
        "explanation": "\"226\" could be decoded as \"BZ\" (2 26), \"VF\" (22 6), or \"BBF\" (2 2 6)."
      },
      {
        "input": "s = \"06\"",
        "output": "0",
        "explanation": "\"06\" cannot be mapped because 0 is not a valid encoding."
      }
    ],
    "functionSignature": "def numDecodings(s: str) -> int:",
    "starterCode": "def numDecodings(s: str) -> int:\n    # Write your solution here\n    pass",
    "tags": ["Strings", "Dynamic Programming"]
  },
  {
    "id": "kth-largest-element",
    "title": "Kth Largest Element in an Array",
    "difficulty": "Medium",
    "description": "Given an integer array `nums` and an integer `k`, return the kth largest element in the array.\n\nNote that it is the kth largest element in the sorted order, not the kth distinct element.",
    "examples": [
      {
        "input": "nums = [3,2,1,5,6,4], k = 2",
        "output": "5",
        "explanation": null
      },
      {
        "input": "nums = [3,2,3,1,2,4,5,5,6], k = 4",
        "output": "4",
        "explanation": null
      }
    ],
    "functionSignature": "def findKthLargest(nums: list[int], k: int) -> int:",
    "starterCode": "def findKthLargest(nums: list[int], k: int) -> int:\n    # Write your solution here\n    pass",
    "tags": ["Arrays", "Sorting"]
  },
  {
    "id": "first-missing-positive",
    "title": "First Missing Positive",
    "difficulty": "Hard",
    "description": "Given an unsorted integer array `nums`, return the smallest missing positive integer.\n\nYou must implement an algorithm that runs in O(n) time and uses O(1) auxiliary space.",
    "examples": [
      {
        "input": "nums = [1,2,0]",
        "output": "3",
        "explanation": "Numbers 1 and 2 are present, so 3 is the smallest missing positive."
      },
      {
        "input": "nums = [3,4,-1,1]",
        "output": "2",
        "explanation": "1 is present but 2 is missing."
      },
      {
        "input": "nums = [7,8,9,11,12]",
        "output": "1",
        "explanation": "1 is the smallest positive integer."
      }
    ],
    "functionSignature": "def firstMissingPositive(nums: list[int]) -> int:",
    "starterCode": "def firstMissingPositive(nums: list[int]) -> int:\n    # Write your solution here\n    pass",
    "tags": ["Arrays", "Hash Map"]
  },
  {
    "id": "minimum-window-substring",
    "title": "Minimum Window Substring",
    "difficulty": "Hard",
    "description": "Given two strings `s` and `t` of lengths `m` and `n` respectively, return the minimum window substring of `s` such that every character in `t` (including duplicates) is included in the window.\n\nIf there is no such substring, return the empty string \"\".",
    "examples": [
      {
        "input": "s = \"ADOBECODEBANC\", t = \"ABC\"",
        "output": "\"BANC\"",
        "explanation": "The minimum window substring \"BANC\" includes 'A', 'B', and 'C' from string t."
      },
      {
        "input": "s = \"a\", t = \"a\"",
        "output": "\"a\"",
        "explanation": null
      },
      {
        "input": "s = \"a\", t = \"aa\"",
        "output": "\"\"",
        "explanation": "Both 'a's from t must be included. Since s only has one 'a', return empty string."
      }
    ],
    "functionSignature": "def minWindow(s: str, t: str) -> str:",
    "starterCode": "def minWindow(s: str, t: str) -> str:\n    # Write your solution here\n    pass",
    "tags": ["Strings", "Sliding Window", "Hash Map"]
  },
  {
    "id": "edit-distance",
    "title": "Edit Distance",
    "difficulty": "Hard",
    "description": "Given two strings `word1` and `word2`, return the minimum number of operations required to convert `word1` to `word2`.\n\nYou have three operations: Insert a character, Delete a character, Replace a character.",
    "examples": [
      {
        "input": "word1 = \"horse\", word2 = \"ros\"",
        "output": "3",
        "explanation": "horse -> rorse (replace 'h' with 'r') -> rose (remove 'r') -> ros (remove 'e')"
      },
      {
        "input": "word1 = \"intention\", word2 = \"execution\"",
        "output": "5",
        "explanation": null
      }
    ],
    "functionSignature": "def minDistance(word1: str, word2: str) -> int:",
    "starterCode": "def minDistance(word1: str, word2: str) -> int:\n    # Write your solution here\n    pass",
    "tags": ["Strings", "Dynamic Programming"]
  },
  {
    "id": "largest-rectangle-histogram",
    "title": "Largest Rectangle in Histogram",
    "difficulty": "Hard",
    "description": "Given an array of integers `heights` representing the histogram's bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram.",
    "examples": [
      {
        "input": "heights = [2,1,5,6,2,3]",
        "output": "10",
        "explanation": "The largest rectangle has an area of 10 (bars at index 2 and 3 with height 5)."
      },
      {
        "input": "heights = [2,4]",
        "output": "4",
        "explanation": null
      }
    ],
    "functionSignature": "def largestRectangleArea(heights: list[int]) -> int:",
    "starterCode": "def largestRectangleArea(heights: list[int]) -> int:\n    # Write your solution here\n    pass",
    "tags": ["Stack", "Arrays"]
  }
]

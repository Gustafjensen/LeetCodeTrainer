[
  {
    "id": "tutorial-add-two",
    "title": "Add Two Numbers",
    "difficulty": "Easy",
    "description": "Given two integers a and b, return their sum.",
    "examples": [
      {
        "input": "a = 1, b = 2",
        "output": "3",
        "explanation": "1 + 2 = 3"
      }
    ],
    "functionSignature": "def addTwo(a: int, b: int) -> int:",
    "starterCode": "def addTwo(a: int, b: int) -> int:\n    # Write your solution here\n    pass",
    "tags": ["Tutorial"],
    "hints": ["Use the + operator to add a and b together, then return the result."],
    "solutionExplanation": "Simply return a + b. Time: O(1), Space: O(1).",
    "optimalCode": "def addTwo(a: int, b: int) -> int:\n    return a + b"
  },
  {
    "id": "two-sum",
    "title": "Two Sum",
    "difficulty": "Easy",
    "description": "Given an array of integers `nums` and an integer `target`, return indices of the two numbers such that they add up to `target`.\n\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\n\nYou can return the answer in any order.",
    "examples": [
      {
        "input": "nums = [2,7,11,15], target = 9",
        "output": "[0, 1]",
        "explanation": "Because nums[0] + nums[1] == 9, we return [0, 1]."
      },
      {
        "input": "nums = [3,2,4], target = 6",
        "output": "[1, 2]",
        "explanation": null
      }
    ],
    "functionSignature": "def twoSum(nums: list[int], target: int) -> list[int]:",
    "starterCode": "def twoSum(nums: list[int], target: int) -> list[int]:\n    # Write your solution here\n    pass",
    "tags": [
      "Arrays",
      "Hash Map"
    ],
    "hints": [
      "Consider using a hash map to store values you've already seen as you iterate through the array.",
      "For each element, check if the complement (target minus current element) already exists in your hash map.",
      "Store each number as a key and its index as the value. When you find a complement match, return both indices immediately."
    ],
    "solutionExplanation": "Use a hash map to store each number's index as you iterate. For each element, check if target - current exists in the map. Time: O(n), Space: O(n).",
    "optimalCode": "def twoSum(nums: list[int], target: int) -> list[int]:\n    seen = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen[complement], i]\n        seen[num] = i"
  },
  {
    "id": "reverse-string",
    "title": "Reverse String",
    "difficulty": "Easy",
    "description": "Write a function that reverses a list of characters in place.\n\nDo not allocate extra space for another array. You must do this by modifying the input list in-place with O(1) extra memory.",
    "examples": [
      {
        "input": "s = [\"h\",\"e\",\"l\",\"l\",\"o\"]",
        "output": "[\"o\",\"l\",\"l\",\"e\",\"h\"]",
        "explanation": null
      },
      {
        "input": "s = [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]",
        "output": "[\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]",
        "explanation": null
      }
    ],
    "functionSignature": "def reverseString(s: list[str]) -> list[str]:",
    "starterCode": "def reverseString(s: list[str]) -> list[str]:\n    # Modify s in-place and return it\n    pass",
    "tags": [
      "Two Pointers",
      "Strings"
    ],
    "hints": [
      "Think about using two pointers, one starting at the beginning and one at the end of the array.",
      "Swap the characters at the left and right pointers, then move both pointers toward the center.",
      "Continue swapping until the left pointer meets or passes the right pointer. No extra space is needed beyond the two pointer variables."
    ],
    "solutionExplanation": "Use two pointers starting at the beginning and end, swapping characters and moving inward. This reverses in-place with no extra space. Time: O(n), Space: O(1).",
    "optimalCode": "def reverseString(s: list[str]) -> list[str]:\n    left, right = 0, len(s) - 1\n    while left < right:\n        s[left], s[right] = s[right], s[left]\n        left += 1\n        right -= 1\n    return s"
  },
  {
    "id": "fizz-buzz",
    "title": "FizzBuzz",
    "difficulty": "Easy",
    "description": "Given an integer `n`, return a string array `answer` (1-indexed) where:\n\n- `answer[i] == \"FizzBuzz\"` if `i` is divisible by 3 and 5.\n- `answer[i] == \"Fizz\"` if `i` is divisible by 3.\n- `answer[i] == \"Buzz\"` if `i` is divisible by 5.\n- `answer[i] == i` (as a string) if none of the above conditions are true.",
    "examples": [
      {
        "input": "n = 3",
        "output": "[\"1\",\"2\",\"Fizz\"]",
        "explanation": null
      },
      {
        "input": "n = 5",
        "output": "[\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\"]",
        "explanation": null
      },
      {
        "input": "n = 15",
        "output": "[\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\",\"Fizz\",\"7\",\"8\",\"Fizz\",\"Buzz\",\"11\",\"Fizz\",\"13\",\"14\",\"FizzBuzz\"]",
        "explanation": null
      }
    ],
    "functionSignature": "def fizzBuzz(n: int) -> list[str]:",
    "starterCode": "def fizzBuzz(n: int) -> list[str]:\n    # Write your solution here\n    pass",
    "tags": [
      "Math",
      "Simulation"
    ],
    "hints": [
      "Iterate from 1 to n and check divisibility conditions for each number.",
      "Check divisibility by 15 first (for FizzBuzz), then by 3 (for Fizz), then by 5 (for Buzz), using the modulo operator.",
      "The order of checks matters: test the combined condition (divisible by both 3 and 5) before the individual conditions to avoid incorrect outputs."
    ],
    "solutionExplanation": "Iterate from 1 to n, checking divisibility by 15 first, then 3, then 5, appending the appropriate string. Time: O(n), Space: O(n).",
    "optimalCode": "def fizzBuzz(n: int) -> list[str]:\n    result = []\n    for i in range(1, n + 1):\n        if i % 15 == 0:\n            result.append(\"FizzBuzz\")\n        elif i % 3 == 0:\n            result.append(\"Fizz\")\n        elif i % 5 == 0:\n            result.append(\"Buzz\")\n        else:\n            result.append(str(i))\n    return result"
  },
  {
    "id": "valid-palindrome",
    "title": "Valid Palindrome",
    "difficulty": "Easy",
    "description": "A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.\n\nGiven a string `s`, return `true` if it is a palindrome, or `false` otherwise.",
    "examples": [
      {
        "input": "s = \"A man, a plan, a canal: Panama\"",
        "output": "true",
        "explanation": "\"amanaplanacanalpanama\" is a palindrome."
      },
      {
        "input": "s = \"race a car\"",
        "output": "false",
        "explanation": "\"raceacar\" is not a palindrome."
      },
      {
        "input": "s = \" \"",
        "output": "true",
        "explanation": "After removing non-alphanumeric characters, s is an empty string."
      }
    ],
    "functionSignature": "def isPalindrome(s: str) -> bool:",
    "starterCode": "def isPalindrome(s: str) -> bool:\n    # Write your solution here\n    pass",
    "tags": [
      "Strings",
      "Two Pointers"
    ],
    "hints": [
      "Consider using two pointers starting from the beginning and end of the string.",
      "Skip non-alphanumeric characters by advancing the pointers, and compare characters in lowercase.",
      "Be careful with edge cases: empty strings and strings with only non-alphanumeric characters should return true."
    ],
    "solutionExplanation": "Use two pointers from both ends, skipping non-alphanumeric characters and comparing lowercase versions. Time: O(n), Space: O(1).",
    "optimalCode": "def isPalindrome(s: str) -> bool:\n    left, right = 0, len(s) - 1\n    while left < right:\n        while left < right and not s[left].isalnum():\n            left += 1\n        while left < right and not s[right].isalnum():\n            right -= 1\n        if s[left].lower() != s[right].lower():\n            return False\n        left += 1\n        right -= 1\n    return True"
  },
  {
    "id": "climbing-stairs",
    "title": "Climbing Stairs",
    "difficulty": "Easy",
    "description": "You are climbing a staircase. It takes `n` steps to reach the top.\n\nEach time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?",
    "examples": [
      {
        "input": "n = 2",
        "output": "2",
        "explanation": "There are two ways to climb to the top: 1+1 and 2."
      },
      {
        "input": "n = 3",
        "output": "3",
        "explanation": "There are three ways to climb to the top: 1+1+1, 1+2, and 2+1."
      }
    ],
    "functionSignature": "def climbStairs(n: int) -> int:",
    "starterCode": "def climbStairs(n: int) -> int:\n    # Write your solution here\n    pass",
    "tags": [
      "Dynamic Programming",
      "Recursion"
    ],
    "hints": [
      "Think about how the number of ways to reach step n relates to the number of ways to reach previous steps.",
      "This follows the Fibonacci pattern: the ways to reach step n equals the sum of ways to reach step n-1 and step n-2.",
      "You only need two variables to track the previous two values instead of a full array. Base cases are: 1 way for step 1, 2 ways for step 2."
    ],
    "solutionExplanation": "This is a Fibonacci-like dynamic programming problem. Each step can be reached from one or two steps below, so dp[i] = dp[i-1] + dp[i-2]. Time: O(n), Space: O(1).",
    "optimalCode": "def climbStairs(n: int) -> int:\n    if n <= 2:\n        return n\n    a, b = 1, 2\n    for _ in range(3, n + 1):\n        a, b = b, a + b\n    return b"
  },
  {
    "id": "contains-duplicate",
    "title": "Contains Duplicate",
    "difficulty": "Easy",
    "description": "Given an integer array `nums`, return `true` if any value appears at least twice in the array, and return `false` if every element is distinct.",
    "examples": [
      {
        "input": "nums = [1,2,3,1]",
        "output": "true",
        "explanation": null
      },
      {
        "input": "nums = [1,2,3,4]",
        "output": "false",
        "explanation": null
      },
      {
        "input": "nums = [1,1,1,3,3,4,3,2,4,2]",
        "output": "true",
        "explanation": null
      }
    ],
    "functionSignature": "def containsDuplicate(nums: list[int]) -> bool:",
    "starterCode": "def containsDuplicate(nums: list[int]) -> bool:\n    # Write your solution here\n    pass",
    "tags": [
      "Arrays",
      "Hash Map"
    ],
    "hints": [
      "Think about a data structure that can efficiently check if an element has been seen before.",
      "Use a set to track elements as you iterate. Sets provide O(1) lookup time.",
      "For each element, check if it already exists in the set before adding it. If it does, return true immediately."
    ],
    "solutionExplanation": "Add each element to a set while iterating. If an element is already in the set, return true. Time: O(n), Space: O(n).",
    "optimalCode": "def containsDuplicate(nums: list[int]) -> bool:\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False"
  },
  {
    "id": "valid-anagram",
    "title": "Valid Anagram",
    "difficulty": "Easy",
    "description": "Given two strings `s` and `t`, return `true` if `t` is an anagram of `s`, and `false` otherwise.\n\nAn anagram is a word formed by rearranging the letters of a different word, using all the original letters exactly once.",
    "examples": [
      {
        "input": "s = \"anagram\", t = \"nagaram\"",
        "output": "true",
        "explanation": null
      },
      {
        "input": "s = \"rat\", t = \"car\"",
        "output": "false",
        "explanation": null
      }
    ],
    "functionSignature": "def isAnagram(s: str, t: str) -> bool:",
    "starterCode": "def isAnagram(s: str, t: str) -> bool:\n    # Write your solution here\n    pass",
    "tags": [
      "Strings",
      "Hash Map"
    ],
    "hints": [
      "Two strings are anagrams if they contain the same characters with the same frequencies.",
      "Count the frequency of each character in both strings and compare the counts.",
      "You can use a single frequency array of size 26 (for lowercase letters): increment for one string, decrement for the other, then check all counts are zero."
    ],
    "solutionExplanation": "Count character frequencies using a hash map or Counter for both strings and compare. Alternatively, sort both strings and check equality. Time: O(n), Space: O(1) since alphabet is fixed.",
    "optimalCode": "def isAnagram(s: str, t: str) -> bool:\n    if len(s) != len(t):\n        return False\n    count = {}\n    for c in s:\n        count[c] = count.get(c, 0) + 1\n    for c in t:\n        count[c] = count.get(c, 0) - 1\n        if count[c] < 0:\n            return False\n    return True"
  },
  {
    "id": "palindrome-number",
    "title": "Palindrome Number",
    "difficulty": "Easy",
    "description": "Given an integer `x`, return `true` if `x` is a palindrome, and `false` otherwise.\n\nAn integer is a palindrome when it reads the same backward as forward. For example, 121 is a palindrome while 123 is not.",
    "examples": [
      {
        "input": "x = 121",
        "output": "true",
        "explanation": "121 reads as 121 from left to right and from right to left."
      },
      {
        "input": "x = -121",
        "output": "false",
        "explanation": "From left to right, it reads -121. From right to left it becomes 121-."
      },
      {
        "input": "x = 10",
        "output": "false",
        "explanation": "Reads 01 from right to left."
      }
    ],
    "functionSignature": "def isPalindromeNumber(x: int) -> bool:",
    "starterCode": "def isPalindromeNumber(x: int) -> bool:\n    # Write your solution here\n    pass",
    "tags": [
      "Math"
    ],
    "hints": [
      "Consider how to check if a number reads the same forwards and backwards without converting to a string.",
      "You can reverse just the second half of the number and compare it to the first half.",
      "Negative numbers are never palindromes. Numbers ending in 0 (except 0 itself) are not palindromes. Stop reversing when the reversed half is greater than or equal to the remaining number."
    ],
    "solutionExplanation": "Reverse the second half of the number and compare with the first half. Negative numbers and numbers ending in 0 (except 0 itself) are not palindromes. Time: O(log n), Space: O(1).",
    "optimalCode": "def isPalindromeNumber(x: int) -> bool:\n    if x < 0 or (x % 10 == 0 and x != 0):\n        return False\n    reversed_half = 0\n    while x > reversed_half:\n        reversed_half = reversed_half * 10 + x % 10\n        x //= 10\n    return x == reversed_half or x == reversed_half // 10"
  },
  {
    "id": "roman-to-integer",
    "title": "Roman to Integer",
    "difficulty": "Easy",
    "description": "Roman numerals are represented by seven symbols: I (1), V (5), X (10), L (50), C (100), D (500), M (1000).\n\nGiven a roman numeral string, convert it to an integer.\n\nSubtraction is used when a smaller value appears before a larger value (e.g. IV = 4, IX = 9).",
    "examples": [
      {
        "input": "s = \"III\"",
        "output": "3",
        "explanation": "III = 3"
      },
      {
        "input": "s = \"LVIII\"",
        "output": "58",
        "explanation": "L = 50, V = 5, III = 3"
      },
      {
        "input": "s = \"MCMXCIV\"",
        "output": "1994",
        "explanation": "M = 1000, CM = 900, XC = 90, IV = 4"
      }
    ],
    "functionSignature": "def romanToInt(s: str) -> int:",
    "starterCode": "def romanToInt(s: str) -> int:\n    # Write your solution here\n    pass",
    "tags": [
      "Math",
      "Strings"
    ],
    "hints": [
      "Create a mapping from each Roman numeral character to its integer value.",
      "Iterate through the string; if the current value is less than the next value, subtract it instead of adding it.",
      "Handle the subtraction cases (IV, IX, XL, XC, CD, CM) by comparing adjacent characters. Process the string from left to right."
    ],
    "solutionExplanation": "Iterate through the string, adding the value of each symbol. If a smaller value precedes a larger one, subtract it instead. Time: O(n), Space: O(1).",
    "optimalCode": "def romanToInt(s: str) -> int:\n    values = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}\n    result = 0\n    for i in range(len(s)):\n        if i + 1 < len(s) and values[s[i]] < values[s[i + 1]]:\n            result -= values[s[i]]\n        else:\n            result += values[s[i]]\n    return result"
  },
  {
    "id": "longest-common-prefix",
    "title": "Longest Common Prefix",
    "difficulty": "Easy",
    "description": "Write a function to find the longest common prefix string amongst an array of strings.\n\nIf there is no common prefix, return an empty string \"\".",
    "examples": [
      {
        "input": "strs = [\"flower\",\"flow\",\"flight\"]",
        "output": "\"fl\"",
        "explanation": null
      },
      {
        "input": "strs = [\"dog\",\"racecar\",\"car\"]",
        "output": "\"\"",
        "explanation": "There is no common prefix among the input strings."
      }
    ],
    "functionSignature": "def longestCommonPrefix(strs: list[str]) -> str:",
    "starterCode": "def longestCommonPrefix(strs: list[str]) -> str:\n    # Write your solution here\n    pass",
    "tags": [
      "Strings"
    ],
    "hints": [
      "Compare characters at the same position across all strings simultaneously.",
      "Use the first string as a reference and check each character position against all other strings.",
      "Stop as soon as you find a mismatch or reach the end of the shortest string. Return the substring up to that position."
    ],
    "solutionExplanation": "Compare characters at each position across all strings. Stop when characters differ or the shortest string ends. Time: O(n * m) where m is prefix length, Space: O(1).",
    "optimalCode": "def longestCommonPrefix(strs: list[str]) -> str:\n    if not strs:\n        return \"\"\n    for i in range(len(strs[0])):\n        for s in strs[1:]:\n            if i >= len(s) or s[i] != strs[0][i]:\n                return strs[0][:i]\n    return strs[0]"
  },
  {
    "id": "length-of-last-word",
    "title": "Length of Last Word",
    "difficulty": "Easy",
    "description": "Given a string `s` consisting of words and spaces, return the length of the last word in the string.\n\nA word is a maximal substring consisting of non-space characters only.",
    "examples": [
      {
        "input": "s = \"Hello World\"",
        "output": "5",
        "explanation": "The last word is \"World\" with length 5."
      },
      {
        "input": "s = \"   fly me   to   the moon  \"",
        "output": "4",
        "explanation": "The last word is \"moon\" with length 4."
      },
      {
        "input": "s = \"luffy is still joyboy\"",
        "output": "6",
        "explanation": "The last word is \"joyboy\" with length 6."
      }
    ],
    "functionSignature": "def lengthOfLastWord(s: str) -> int:",
    "starterCode": "def lengthOfLastWord(s: str) -> int:\n    # Write your solution here\n    pass",
    "tags": [
      "Strings"
    ],
    "hints": [
      "Think about traversing the string from the end to find the last word.",
      "First skip any trailing spaces, then count characters until you hit another space or the start of the string.",
      "Alternatively, use built-in string trimming and splitting, but be mindful of multiple consecutive spaces."
    ],
    "solutionExplanation": "Strip trailing spaces, then count backwards from the end until hitting a space or the start. Time: O(n), Space: O(1).",
    "optimalCode": "def lengthOfLastWord(s: str) -> int:\n    return len(s.rstrip().split(' ')[-1])"
  },
  {
    "id": "search-insert-position",
    "title": "Search Insert Position",
    "difficulty": "Easy",
    "description": "Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n\nYou must write an algorithm with O(log n) runtime complexity.",
    "examples": [
      {
        "input": "nums = [1,3,5,6], target = 5",
        "output": "2",
        "explanation": null
      },
      {
        "input": "nums = [1,3,5,6], target = 2",
        "output": "1",
        "explanation": null
      },
      {
        "input": "nums = [1,3,5,6], target = 7",
        "output": "4",
        "explanation": null
      }
    ],
    "functionSignature": "def searchInsert(nums: list[int], target: int) -> int:",
    "starterCode": "def searchInsert(nums: list[int], target: int) -> int:\n    # Write your solution here\n    pass",
    "tags": [
      "Binary Search",
      "Arrays"
    ],
    "hints": [
      "The requirement for O(log n) runtime points to binary search.",
      "Use standard binary search, but when the target is not found, the left pointer will be at the correct insertion position.",
      "Maintain left and right bounds. When left > right, return left as the insertion index."
    ],
    "solutionExplanation": "Use binary search to find the target or its insertion point. Maintain left and right bounds, returning left when the loop ends. Time: O(log n), Space: O(1).",
    "optimalCode": "def searchInsert(nums: list[int], target: int) -> int:\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return left"
  },
  {
    "id": "single-number",
    "title": "Single Number",
    "difficulty": "Easy",
    "description": "Given a non-empty array of integers `nums`, every element appears twice except for one. Find that single one.\n\nYou must implement a solution with linear runtime complexity and use only constant extra space.",
    "examples": [
      {
        "input": "nums = [2,2,1]",
        "output": "1",
        "explanation": null
      },
      {
        "input": "nums = [4,1,2,1,2]",
        "output": "4",
        "explanation": null
      },
      {
        "input": "nums = [1]",
        "output": "1",
        "explanation": null
      }
    ],
    "functionSignature": "def singleNumber(nums: list[int]) -> int:",
    "starterCode": "def singleNumber(nums: list[int]) -> int:\n    # Write your solution here\n    pass",
    "tags": [
      "Arrays",
      "Bit Manipulation"
    ],
    "hints": [
      "Think about a bitwise operation where pairing identical values cancels them out.",
      "XOR has the property that a ^ a = 0 and a ^ 0 = a, so XORing all elements cancels out duplicates.",
      "Simply XOR all elements in the array together. The final result is the single number since all pairs cancel to zero."
    ],
    "solutionExplanation": "XOR all elements together. Since a ^ a = 0 and a ^ 0 = a, all pairs cancel out leaving the single number. Time: O(n), Space: O(1).",
    "optimalCode": "def singleNumber(nums: list[int]) -> int:\n    result = 0\n    for num in nums:\n        result ^= num\n    return result"
  },
  {
    "id": "missing-number",
    "title": "Missing Number",
    "difficulty": "Easy",
    "description": "Given an array `nums` containing `n` distinct numbers in the range `[0, n]`, return the only number in the range that is missing from the array.",
    "examples": [
      {
        "input": "nums = [3,0,1]",
        "output": "2",
        "explanation": "n = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is missing."
      },
      {
        "input": "nums = [0,1]",
        "output": "2",
        "explanation": "n = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is missing."
      },
      {
        "input": "nums = [9,6,4,2,3,5,7,0,1]",
        "output": "8",
        "explanation": null
      }
    ],
    "functionSignature": "def missingNumber(nums: list[int]) -> int:",
    "starterCode": "def missingNumber(nums: list[int]) -> int:\n    # Write your solution here\n    pass",
    "tags": [
      "Arrays",
      "Math"
    ],
    "hints": [
      "Think about the mathematical relationship between the expected sum of 0 to n and the actual sum of the array.",
      "The expected sum is n * (n + 1) / 2. Subtract the actual array sum to find the missing number.",
      "Alternatively, XOR all numbers from 0 to n with all array elements. Paired values cancel, leaving the missing number."
    ],
    "solutionExplanation": "Use the sum formula n*(n+1)/2 and subtract the array sum to find the missing number. Alternatively, use XOR. Time: O(n), Space: O(1).",
    "optimalCode": "def missingNumber(nums: list[int]) -> int:\n    n = len(nums)\n    return n * (n + 1) // 2 - sum(nums)"
  },
  {
    "id": "ransom-note",
    "title": "Ransom Note",
    "difficulty": "Easy",
    "description": "Given two strings `ransomNote` and `magazine`, return `true` if `ransomNote` can be constructed by using the letters from `magazine` and `false` otherwise.\n\nEach letter in `magazine` can only be used once in `ransomNote`.",
    "examples": [
      {
        "input": "ransomNote = \"a\", magazine = \"b\"",
        "output": "false",
        "explanation": null
      },
      {
        "input": "ransomNote = \"aa\", magazine = \"ab\"",
        "output": "false",
        "explanation": null
      },
      {
        "input": "ransomNote = \"aa\", magazine = \"aab\"",
        "output": "true",
        "explanation": null
      }
    ],
    "functionSignature": "def canConstruct(ransomNote: str, magazine: str) -> bool:",
    "starterCode": "def canConstruct(ransomNote: str, magazine: str) -> bool:\n    # Write your solution here\n    pass",
    "tags": [
      "Hash Map",
      "Strings"
    ],
    "hints": [
      "Think about counting character frequencies in the magazine to see if they cover the ransom note.",
      "Build a frequency map of magazine characters, then check if each ransom note character has sufficient count.",
      "Decrement counts as you use characters from the magazine. If any character count goes below zero, the ransom note cannot be constructed."
    ],
    "solutionExplanation": "Count character frequencies in magazine using a hash map, then verify each character in ransomNote has sufficient count. Time: O(n + m), Space: O(1).",
    "optimalCode": "def canConstruct(ransomNote: str, magazine: str) -> bool:\n    count = {}\n    for c in magazine:\n        count[c] = count.get(c, 0) + 1\n    for c in ransomNote:\n        if count.get(c, 0) <= 0:\n            return False\n        count[c] -= 1\n    return True"
  },
  {
    "id": "isomorphic-strings",
    "title": "Isomorphic Strings",
    "difficulty": "Easy",
    "description": "Given two strings `s` and `t`, determine if they are isomorphic.\n\nTwo strings are isomorphic if the characters in `s` can be replaced to get `t`. All occurrences of a character must be replaced with another character while preserving the order. No two characters may map to the same character, but a character may map to itself.",
    "examples": [
      {
        "input": "s = \"egg\", t = \"add\"",
        "output": "true",
        "explanation": null
      },
      {
        "input": "s = \"foo\", t = \"bar\"",
        "output": "false",
        "explanation": null
      },
      {
        "input": "s = \"paper\", t = \"title\"",
        "output": "true",
        "explanation": null
      }
    ],
    "functionSignature": "def isIsomorphic(s: str, t: str) -> bool:",
    "starterCode": "def isIsomorphic(s: str, t: str) -> bool:\n    # Write your solution here\n    pass",
    "tags": [
      "Hash Map",
      "Strings"
    ],
    "hints": [
      "Think about creating a mapping between characters of the two strings.",
      "You need two mappings: one from s to t and one from t to s, to ensure the mapping is bidirectional (one-to-one).",
      "If a character in s already maps to a different character in t (or vice versa), the strings are not isomorphic. Check both directions at each position."
    ],
    "solutionExplanation": "Use two hash maps to track character mappings in both directions (s->t and t->s). If any mapping conflicts, return false. Time: O(n), Space: O(1).",
    "optimalCode": "def isIsomorphic(s: str, t: str) -> bool:\n    s_to_t = {}\n    t_to_s = {}\n    for cs, ct in zip(s, t):\n        if cs in s_to_t and s_to_t[cs] != ct:\n            return False\n        if ct in t_to_s and t_to_s[ct] != cs:\n            return False\n        s_to_t[cs] = ct\n        t_to_s[ct] = cs\n    return True"
  },
  {
    "id": "best-time-to-buy-sell-stock",
    "title": "Best Time to Buy and Sell Stock",
    "difficulty": "Easy",
    "description": "You are given an array `prices` where `prices[i]` is the price of a given stock on the ith day.\n\nYou want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\n\nReturn the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.",
    "examples": [
      {
        "input": "prices = [7,1,5,3,6,4]",
        "output": "5",
        "explanation": "Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5."
      },
      {
        "input": "prices = [7,6,4,3,1]",
        "output": "0",
        "explanation": "No profitable transaction is possible."
      }
    ],
    "functionSignature": "def maxProfit(prices: list[int]) -> int:",
    "starterCode": "def maxProfit(prices: list[int]) -> int:\n    # Write your solution here\n    pass",
    "tags": [
      "Arrays",
      "Greedy"
    ],
    "hints": [
      "You need to find the maximum difference between a later price and an earlier price.",
      "Keep track of the minimum price seen so far as you iterate through the array.",
      "At each day, calculate the profit if you sold today (current price minus minimum so far) and update the maximum profit. Remember you must buy before you sell."
    ],
    "solutionExplanation": "Track the minimum price seen so far while iterating. At each step, calculate profit if selling today and update the maximum profit. Time: O(n), Space: O(1).",
    "optimalCode": "def maxProfit(prices: list[int]) -> int:\n    min_price = float('inf')\n    max_profit = 0\n    for price in prices:\n        min_price = min(min_price, price)\n        max_profit = max(max_profit, price - min_price)\n    return max_profit"
  },
  {
    "id": "move-zeroes",
    "title": "Move Zeroes",
    "difficulty": "Easy",
    "description": "Given an integer array `nums`, move all 0's to the end of it while maintaining the relative order of the non-zero elements.\n\nNote that you must do this in-place without making a copy of the array. Return the modified array.",
    "examples": [
      {
        "input": "nums = [0,1,0,3,12]",
        "output": "[1,3,12,0,0]",
        "explanation": null
      },
      {
        "input": "nums = [0]",
        "output": "[0]",
        "explanation": null
      }
    ],
    "functionSignature": "def moveZeroes(nums: list[int]) -> list[int]:",
    "starterCode": "def moveZeroes(nums: list[int]) -> list[int]:\n    # Modify nums in-place and return it\n    pass",
    "tags": [
      "Arrays",
      "Two Pointers"
    ],
    "hints": [
      "Consider using a pointer to track where the next non-zero element should be placed.",
      "Iterate through the array; whenever you find a non-zero element, place it at the write pointer position and advance the write pointer.",
      "After all non-zero elements are moved forward, fill the remaining positions with zeros."
    ],
    "solutionExplanation": "Use a two-pointer approach: one pointer tracks the position for the next non-zero element. Move non-zero elements forward and fill remaining positions with zeros. Time: O(n), Space: O(1).",
    "optimalCode": "def moveZeroes(nums: list[int]) -> list[int]:\n    write = 0\n    for read in range(len(nums)):\n        if nums[read] != 0:\n            nums[write], nums[read] = nums[read], nums[write]\n            write += 1\n    return nums"
  },
  {
    "id": "plus-one",
    "title": "Plus One",
    "difficulty": "Easy",
    "description": "You are given a large integer represented as an integer array `digits`, where each `digits[i]` is the ith digit of the integer. The digits are ordered from most significant to least significant.\n\nIncrement the large integer by one and return the resulting array of digits.",
    "examples": [
      {
        "input": "digits = [1,2,3]",
        "output": "[1,2,4]",
        "explanation": "The array represents the integer 123. 123 + 1 = 124."
      },
      {
        "input": "digits = [4,3,2,1]",
        "output": "[4,3,2,2]",
        "explanation": null
      },
      {
        "input": "digits = [9]",
        "output": "[1,0]",
        "explanation": null
      }
    ],
    "functionSignature": "def plusOne(digits: list[int]) -> list[int]:",
    "starterCode": "def plusOne(digits: list[int]) -> list[int]:\n    # Write your solution here\n    pass",
    "tags": [
      "Arrays",
      "Math"
    ],
    "hints": [
      "Start from the last digit and work backwards, handling the carry.",
      "If a digit is 9, it becomes 0 and you carry 1 to the next digit. Otherwise, increment and return.",
      "If the carry propagates past the first digit (e.g., 999 becomes 1000), prepend a 1 to the array."
    ],
    "solutionExplanation": "Iterate from the last digit backward, adding carry. If a digit becomes 10, set to 0 and carry 1. If carry remains after the loop, prepend 1. Time: O(n), Space: O(1).",
    "optimalCode": "def plusOne(digits: list[int]) -> list[int]:\n    for i in range(len(digits) - 1, -1, -1):\n        if digits[i] < 9:\n            digits[i] += 1\n            return digits\n        digits[i] = 0\n    return [1] + digits"
  },
  {
    "id": "max-subarray",
    "title": "Maximum Subarray",
    "difficulty": "Medium",
    "description": "Given an integer array `nums`, find the subarray with the largest sum, and return its sum.\n\nA subarray is a contiguous non-empty sequence of elements within an array.",
    "examples": [
      {
        "input": "nums = [-2,1,-3,4,-1,2,1,-5,4]",
        "output": "6",
        "explanation": "The subarray [4,-1,2,1] has the largest sum 6."
      },
      {
        "input": "nums = [1]",
        "output": "1",
        "explanation": "The subarray [1] has the largest sum 1."
      },
      {
        "input": "nums = [5,4,-1,7,8]",
        "output": "23",
        "explanation": "The subarray [5,4,-1,7,8] has the largest sum 23."
      }
    ],
    "functionSignature": "def maxSubArray(nums: list[int]) -> int:",
    "starterCode": "def maxSubArray(nums: list[int]) -> int:\n    # Write your solution here\n    pass",
    "tags": [
      "Arrays",
      "Dynamic Programming"
    ],
    "hints": [
      "Think about Kadane's algorithm: decide at each element whether to extend the current subarray or start fresh.",
      "Maintain a running sum. If the running sum becomes negative, reset it to the current element since a negative prefix only hurts.",
      "Track the global maximum separately from the running sum. Initialize both with the first element to handle all-negative arrays correctly."
    ],
    "solutionExplanation": "Use Kadane's algorithm: maintain a running sum, resetting to the current element when the sum becomes negative. Track the maximum sum seen. Time: O(n), Space: O(1).",
    "optimalCode": "def maxSubArray(nums: list[int]) -> int:\n    max_sum = nums[0]\n    current_sum = nums[0]\n    for i in range(1, len(nums)):\n        current_sum = max(nums[i], current_sum + nums[i])\n        max_sum = max(max_sum, current_sum)\n    return max_sum"
  },
  {
    "id": "valid-parentheses",
    "title": "Valid Parentheses",
    "difficulty": "Medium",
    "description": "Given a string `s` containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\n\nAn input string is valid if:\n1. Open brackets must be closed by the same type of brackets.\n2. Open brackets must be closed in the correct order.\n3. Every close bracket has a corresponding open bracket of the same type.",
    "examples": [
      {
        "input": "s = \"()\"",
        "output": "true",
        "explanation": null
      },
      {
        "input": "s = \"()[]{}\"",
        "output": "true",
        "explanation": null
      },
      {
        "input": "s = \"(]\"",
        "output": "false",
        "explanation": null
      }
    ],
    "functionSignature": "def isValid(s: str) -> bool:",
    "starterCode": "def isValid(s: str) -> bool:\n    # Write your solution here\n    pass",
    "tags": [
      "Stack",
      "Strings"
    ],
    "hints": [
      "Consider using a stack to keep track of opening brackets.",
      "Push opening brackets onto the stack. When you encounter a closing bracket, check if the top of the stack is the matching opening bracket.",
      "If the stack is empty when you see a closing bracket, or the brackets don't match, return false. The string is valid only if the stack is empty at the end."
    ],
    "solutionExplanation": "Use a stack: push opening brackets, and for closing brackets, check if the top of the stack matches. The string is valid if the stack is empty at the end. Time: O(n), Space: O(n).",
    "optimalCode": "def isValid(s: str) -> bool:\n    stack = []\n    mapping = {')': '(', '}': '{', ']': '['}\n    for char in s:\n        if char in mapping:\n            if not stack or stack[-1] != mapping[char]:\n                return False\n            stack.pop()\n        else:\n            stack.append(char)\n    return len(stack) == 0"
  },
  {
    "id": "merge-sorted-lists",
    "title": "Merge Two Sorted Lists",
    "difficulty": "Medium",
    "description": "You are given two sorted integer arrays `list1` and `list2`. Merge them into a single sorted array and return it.\n\nThe resulting array should be made by splicing together the values from the two input arrays in sorted order.",
    "examples": [
      {
        "input": "list1 = [1,2,4], list2 = [1,3,4]",
        "output": "[1,1,2,3,4,4]",
        "explanation": null
      },
      {
        "input": "list1 = [], list2 = []",
        "output": "[]",
        "explanation": null
      },
      {
        "input": "list1 = [], list2 = [0]",
        "output": "[0]",
        "explanation": null
      }
    ],
    "functionSignature": "def mergeTwoLists(list1: list[int], list2: list[int]) -> list[int]:",
    "starterCode": "def mergeTwoLists(list1: list[int], list2: list[int]) -> list[int]:\n    # Write your solution here\n    pass",
    "tags": [
      "Arrays",
      "Sorting"
    ],
    "hints": [
      "Use two pointers, one for each list, and compare elements to build the merged result.",
      "At each step, append the smaller of the two current elements to the result and advance that pointer.",
      "When one list is exhausted, append all remaining elements from the other list."
    ],
    "solutionExplanation": "Use two pointers to compare elements from both lists, appending the smaller one to the result. Append any remaining elements. Time: O(n + m), Space: O(n + m).",
    "optimalCode": "def mergeTwoLists(list1: list[int], list2: list[int]) -> list[int]:\n    result = []\n    i, j = 0, 0\n    while i < len(list1) and j < len(list2):\n        if list1[i] <= list2[j]:\n            result.append(list1[i])\n            i += 1\n        else:\n            result.append(list2[j])\n            j += 1\n    result.extend(list1[i:])\n    result.extend(list2[j:])\n    return result"
  },
  {
    "id": "group-anagrams",
    "title": "Group Anagrams",
    "difficulty": "Medium",
    "description": "Given an array of strings `strs`, group the anagrams together. You can return the answer in any order.\n\nAn anagram is a word formed by rearranging the letters of another word, using all the original letters exactly once.",
    "examples": [
      {
        "input": "strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]",
        "output": "[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]",
        "explanation": null
      },
      {
        "input": "strs = [\"\"]",
        "output": "[[\"\"]]",
        "explanation": null
      },
      {
        "input": "strs = [\"a\"]",
        "output": "[[\"a\"]]",
        "explanation": null
      }
    ],
    "functionSignature": "def groupAnagrams(strs: list[str]) -> list[list[str]]:",
    "starterCode": "def groupAnagrams(strs: list[str]) -> list[list[str]]:\n    # Write your solution here\n    pass",
    "tags": [
      "Hash Map",
      "Strings",
      "Sorting"
    ],
    "hints": [
      "Think about what makes two words anagrams -- they have the same characters when sorted.",
      "Use the sorted version of each string as a key in a hash map, grouping strings with the same key.",
      "Alternatively, use a character count tuple as the key (e.g., count of each letter a-z) for potentially better performance than sorting each string."
    ],
    "solutionExplanation": "Sort each string to create a key, and group strings with the same sorted key using a hash map. Time: O(n * k log k) where k is max string length, Space: O(n * k).",
    "optimalCode": "def groupAnagrams(strs: list[str]) -> list[list[str]]:\n    groups = {}\n    for s in strs:\n        key = ''.join(sorted(s))\n        if key not in groups:\n            groups[key] = []\n        groups[key].append(s)\n    return list(groups.values())"
  },
  {
    "id": "product-except-self",
    "title": "Product of Array Except Self",
    "difficulty": "Medium",
    "description": "Given an integer array `nums`, return an array `answer` such that `answer[i]` is equal to the product of all the elements of `nums` except `nums[i]`.\n\nYou must write an algorithm that runs in O(n) time and without using the division operation.",
    "examples": [
      {
        "input": "nums = [1,2,3,4]",
        "output": "[24,12,8,6]",
        "explanation": null
      },
      {
        "input": "nums = [-1,1,0,-3,3]",
        "output": "[0,0,9,0,0]",
        "explanation": null
      }
    ],
    "functionSignature": "def productExceptSelf(nums: list[int]) -> list[int]:",
    "starterCode": "def productExceptSelf(nums: list[int]) -> list[int]:\n    # Write your solution here\n    pass",
    "tags": [
      "Arrays"
    ],
    "hints": [
      "Think about computing the product of all elements to the left and right of each index separately.",
      "First pass: build an array of prefix products (product of all elements before index i). Second pass: multiply by suffix products (product of all elements after index i).",
      "You can use the output array for prefix products and a single variable for the running suffix product to achieve O(1) extra space."
    ],
    "solutionExplanation": "Make two passes: first compute prefix products from the left, then multiply with suffix products from the right. This avoids division. Time: O(n), Space: O(1) excluding output.",
    "optimalCode": "def productExceptSelf(nums: list[int]) -> list[int]:\n    n = len(nums)\n    result = [1] * n\n    prefix = 1\n    for i in range(n):\n        result[i] = prefix\n        prefix *= nums[i]\n    suffix = 1\n    for i in range(n - 1, -1, -1):\n        result[i] *= suffix\n        suffix *= nums[i]\n    return result"
  },
  {
    "id": "container-with-most-water",
    "title": "Container With Most Water",
    "difficulty": "Medium",
    "description": "You are given an integer array `height` of length `n`. There are `n` vertical lines drawn such that the two endpoints of the ith line are `(i, 0)` and `(i, height[i])`.\n\nFind two lines that together with the x-axis form a container, such that the container contains the most water.\n\nReturn the maximum amount of water a container can store.",
    "examples": [
      {
        "input": "height = [1,8,6,2,5,4,8,3,7]",
        "output": "49",
        "explanation": "Lines at index 1 and 8 form a container with area 49."
      },
      {
        "input": "height = [1,1]",
        "output": "1",
        "explanation": null
      }
    ],
    "functionSignature": "def maxArea(height: list[int]) -> int:",
    "starterCode": "def maxArea(height: list[int]) -> int:\n    # Write your solution here\n    pass",
    "tags": [
      "Two Pointers",
      "Greedy"
    ],
    "hints": [
      "Think about using two pointers starting at the widest container (both ends of the array).",
      "Calculate the water area as min(height[left], height[right]) * (right - left). Then move the pointer pointing to the shorter line inward.",
      "Moving the shorter line is optimal because the width decreases regardless, so only a taller line can potentially increase the area. The taller line could never benefit from moving inward."
    ],
    "solutionExplanation": "Use two pointers at both ends. Calculate the area, then move the pointer with the shorter line inward. The shorter line limits the area, so moving it might find a taller one. Time: O(n), Space: O(1).",
    "optimalCode": "def maxArea(height: list[int]) -> int:\n    left, right = 0, len(height) - 1\n    max_area = 0\n    while left < right:\n        area = min(height[left], height[right]) * (right - left)\n        max_area = max(max_area, area)\n        if height[left] < height[right]:\n            left += 1\n        else:\n            right -= 1\n    return max_area"
  },
  {
    "id": "three-sum",
    "title": "3Sum",
    "difficulty": "Medium",
    "description": "Given an integer array `nums`, return all the triplets `[nums[i], nums[j], nums[k]]` such that `i != j`, `i != k`, and `j != k`, and `nums[i] + nums[j] + nums[k] == 0`.\n\nNotice that the solution set must not contain duplicate triplets.",
    "examples": [
      {
        "input": "nums = [-1,0,1,2,-1,-4]",
        "output": "[[-1,-1,2],[-1,0,1]]",
        "explanation": null
      },
      {
        "input": "nums = [0,1,1]",
        "output": "[]",
        "explanation": null
      },
      {
        "input": "nums = [0,0,0]",
        "output": "[[0,0,0]]",
        "explanation": null
      }
    ],
    "functionSignature": "def threeSum(nums: list[int]) -> list[list[int]]:",
    "starterCode": "def threeSum(nums: list[int]) -> list[list[int]]:\n    # Write your solution here\n    pass",
    "tags": [
      "Arrays",
      "Two Pointers",
      "Sorting"
    ],
    "hints": [
      "Sorting the array first makes it easier to avoid duplicates and use a two-pointer technique.",
      "For each element, use two pointers on the remaining elements to find pairs that sum to the negative of the current element.",
      "Skip duplicate values for the outer loop and both inner pointers to avoid duplicate triplets. If the current element is positive, you can break early since no three positive numbers sum to zero."
    ],
    "solutionExplanation": "Sort the array, then for each element use two pointers on the remaining elements to find pairs that sum to the negative of the current element. Skip duplicates. Time: O(n²), Space: O(1).",
    "optimalCode": "def threeSum(nums: list[int]) -> list[list[int]]:\n    nums.sort()\n    result = []\n    for i in range(len(nums) - 2):\n        if i > 0 and nums[i] == nums[i - 1]:\n            continue\n        left, right = i + 1, len(nums) - 1\n        while left < right:\n            total = nums[i] + nums[left] + nums[right]\n            if total < 0:\n                left += 1\n            elif total > 0:\n                right -= 1\n            else:\n                result.append([nums[i], nums[left], nums[right]])\n                while left < right and nums[left] == nums[left + 1]:\n                    left += 1\n                while left < right and nums[right] == nums[right - 1]:\n                    right -= 1\n                left += 1\n                right -= 1\n    return result"
  },
  {
    "id": "house-robber",
    "title": "House Robber",
    "difficulty": "Medium",
    "description": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. Adjacent houses have security systems connected — if two adjacent houses were broken into on the same night, the police will be contacted.\n\nGiven an integer array `nums` representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.",
    "examples": [
      {
        "input": "nums = [1,2,3,1]",
        "output": "4",
        "explanation": "Rob house 1 (money = 1) and then rob house 3 (money = 3). Total = 1 + 3 = 4."
      },
      {
        "input": "nums = [2,7,9,3,1]",
        "output": "12",
        "explanation": "Rob house 1 (money = 2), house 3 (money = 9), and house 5 (money = 1). Total = 12."
      }
    ],
    "functionSignature": "def rob(nums: list[int]) -> int:",
    "starterCode": "def rob(nums: list[int]) -> int:\n    # Write your solution here\n    pass",
    "tags": [
      "Dynamic Programming",
      "Arrays"
    ],
    "hints": [
      "This is a dynamic programming problem where each house decision depends on the previous choices.",
      "At each house, you have two choices: rob it (add its value to the best from two houses ago) or skip it (keep the best from the previous house).",
      "The recurrence is dp[i] = max(dp[i-1], dp[i-2] + nums[i]). You only need two variables instead of a full array."
    ],
    "solutionExplanation": "Dynamic programming where dp[i] = max(dp[i-1], dp[i-2] + nums[i]). At each house, choose to rob it (adding to two houses ago) or skip it. Time: O(n), Space: O(1).",
    "optimalCode": "def rob(nums: list[int]) -> int:\n    if not nums:\n        return 0\n    if len(nums) == 1:\n        return nums[0]\n    prev2, prev1 = 0, 0\n    for num in nums:\n        curr = max(prev1, prev2 + num)\n        prev2 = prev1\n        prev1 = curr\n    return prev1"
  },
  {
    "id": "coin-change",
    "title": "Coin Change",
    "difficulty": "Medium",
    "description": "You are given an integer array `coins` representing coins of different denominations and an integer `amount` representing a total amount of money.\n\nReturn the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.\n\nYou may assume that you have an infinite number of each kind of coin.",
    "examples": [
      {
        "input": "coins = [1,5,10], amount = 12",
        "output": "3",
        "explanation": "12 = 10 + 1 + 1"
      },
      {
        "input": "coins = [2], amount = 3",
        "output": "-1",
        "explanation": null
      },
      {
        "input": "coins = [1], amount = 0",
        "output": "0",
        "explanation": null
      }
    ],
    "functionSignature": "def coinChange(coins: list[int], amount: int) -> int:",
    "starterCode": "def coinChange(coins: list[int], amount: int) -> int:\n    # Write your solution here\n    pass",
    "tags": [
      "Dynamic Programming"
    ],
    "hints": [
      "Think about building up the solution from smaller amounts using dynamic programming.",
      "Create a dp array where dp[i] represents the minimum coins needed to make amount i. For each amount, try subtracting each coin denomination.",
      "Initialize dp[0] = 0 and all other values to amount + 1 (representing infinity). If dp[amount] is still greater than amount, return -1."
    ],
    "solutionExplanation": "Use bottom-up dynamic programming. dp[amount] = min coins needed. For each amount, try each coin: dp[i] = min(dp[i], dp[i-coin] + 1). Time: O(amount * coins), Space: O(amount).",
    "optimalCode": "def coinChange(coins: list[int], amount: int) -> int:\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0\n    for i in range(1, amount + 1):\n        for coin in coins:\n            if coin <= i:\n                dp[i] = min(dp[i], dp[i - coin] + 1)\n    return dp[amount] if dp[amount] != float('inf') else -1"
  },
  {
    "id": "unique-paths",
    "title": "Unique Paths",
    "difficulty": "Medium",
    "description": "There is a robot on an `m x n` grid. The robot is initially located at the top-left corner. The robot tries to move to the bottom-right corner. The robot can only move either down or right at any point in time.\n\nGiven the two integers `m` and `n`, return the number of possible unique paths that the robot can take to reach the bottom-right corner.",
    "examples": [
      {
        "input": "m = 3, n = 7",
        "output": "28",
        "explanation": null
      },
      {
        "input": "m = 3, n = 2",
        "output": "3",
        "explanation": "Right+Down+Down, Down+Right+Down, Down+Down+Right."
      }
    ],
    "functionSignature": "def uniquePaths(m: int, n: int) -> int:",
    "starterCode": "def uniquePaths(m: int, n: int) -> int:\n    # Write your solution here\n    pass",
    "tags": [
      "Dynamic Programming",
      "Math"
    ],
    "hints": [
      "Each cell can only be reached from the cell above or the cell to the left.",
      "Use dynamic programming: dp[i][j] = dp[i-1][j] + dp[i][j-1]. Initialize the first row and first column to 1.",
      "You can optimize space to a single row, updating each cell by adding the value from above (already in the row) to the value from the left."
    ],
    "solutionExplanation": "Dynamic programming on a grid where dp[i][j] = dp[i-1][j] + dp[i][j-1]. Each cell can only be reached from above or the left. Can optimize to a single row. Time: O(m*n), Space: O(n).",
    "optimalCode": "def uniquePaths(m: int, n: int) -> int:\n    dp = [1] * n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[j] += dp[j - 1]\n    return dp[n - 1]"
  },
  {
    "id": "jump-game",
    "title": "Jump Game",
    "difficulty": "Medium",
    "description": "You are given an integer array `nums`. You are initially positioned at the array's first index, and each element in the array represents your maximum jump length at that position.\n\nReturn `true` if you can reach the last index, or `false` otherwise.",
    "examples": [
      {
        "input": "nums = [2,3,1,1,4]",
        "output": "true",
        "explanation": "Jump 1 step from index 0 to 1, then 3 steps to the last index."
      },
      {
        "input": "nums = [3,2,1,0,4]",
        "output": "false",
        "explanation": "You will always arrive at index 3 no matter what. Its maximum jump length is 0."
      }
    ],
    "functionSignature": "def canJump(nums: list[int]) -> bool:",
    "starterCode": "def canJump(nums: list[int]) -> bool:\n    # Write your solution here\n    pass",
    "tags": [
      "Greedy",
      "Arrays"
    ],
    "hints": [
      "Think greedily: track the farthest index you can reach as you iterate.",
      "At each position, update the maximum reachable index as max(maxReach, i + nums[i]).",
      "If at any point the current index exceeds the maximum reachable index, you are stuck and should return false. If maxReach reaches the last index, return true."
    ],
    "solutionExplanation": "Greedy approach: track the farthest reachable index. Iterate through the array updating the max reach. If current index exceeds max reach, return false. Time: O(n), Space: O(1).",
    "optimalCode": "def canJump(nums: list[int]) -> bool:\n    max_reach = 0\n    for i in range(len(nums)):\n        if i > max_reach:\n            return False\n        max_reach = max(max_reach, i + nums[i])\n    return True"
  },
  {
    "id": "sort-colors",
    "title": "Sort Colors",
    "difficulty": "Medium",
    "description": "Given an array `nums` with `n` objects colored red (0), white (1), or blue (2), sort them in-place so that objects of the same color are adjacent, in the order red, white, and blue.\n\nYou must solve this problem without using the library's sort function. Return the sorted array.",
    "examples": [
      {
        "input": "nums = [2,0,2,1,1,0]",
        "output": "[0,0,1,1,2,2]",
        "explanation": null
      },
      {
        "input": "nums = [2,0,1]",
        "output": "[0,1,2]",
        "explanation": null
      }
    ],
    "functionSignature": "def sortColors(nums: list[int]) -> list[int]:",
    "starterCode": "def sortColors(nums: list[int]) -> list[int]:\n    # Sort in-place and return nums\n    pass",
    "tags": [
      "Arrays",
      "Two Pointers",
      "Sorting"
    ],
    "hints": [
      "Think about the Dutch National Flag algorithm using three pointers.",
      "Use pointers for the boundary of 0s (low), current element (mid), and boundary of 2s (high). Swap elements to their correct regions.",
      "When mid finds a 0, swap with low and advance both. When mid finds a 2, swap with high and decrement high (don't advance mid since the swapped element needs checking). When mid finds a 1, just advance mid."
    ],
    "solutionExplanation": "Use the Dutch National Flag algorithm with three pointers (low, mid, high). Swap 0s to the front, 2s to the back, leaving 1s in the middle. Time: O(n), Space: O(1).",
    "optimalCode": "def sortColors(nums: list[int]) -> list[int]:\n    low, mid, high = 0, 0, len(nums) - 1\n    while mid <= high:\n        if nums[mid] == 0:\n            nums[low], nums[mid] = nums[mid], nums[low]\n            low += 1\n            mid += 1\n        elif nums[mid] == 1:\n            mid += 1\n        else:\n            nums[mid], nums[high] = nums[high], nums[mid]\n            high -= 1\n    return nums"
  },
  {
    "id": "min-stack",
    "title": "Min Stack",
    "difficulty": "Medium",
    "description": "Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.\n\nImplement the `MinStack` class:\n- `push(val)` pushes the element val onto the stack.\n- `pop()` removes the element on the top of the stack.\n- `top()` gets the top element of the stack.\n- `getMin()` retrieves the minimum element in the stack.\n\nThe function receives a list of operations and a list of arguments, and should return a list of results (None for push/pop).",
    "examples": [
      {
        "input": "ops = [\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"], args = [[-2],[0],[-3],[],[],[],[]]",
        "output": "[None,None,None,-3,None,0,-2]",
        "explanation": null
      }
    ],
    "functionSignature": "def minStack(operations: list[str], arguments: list[list]) -> list:",
    "starterCode": "def minStack(operations: list, arguments: list) -> list:\n    # Implement MinStack and process operations\n    pass",
    "tags": [
      "Stack",
      "Design"
    ],
    "hints": [
      "Think about how to track the minimum efficiently as elements are pushed and popped.",
      "Use an auxiliary stack that stores the current minimum at each level. Push to the min stack whenever a new minimum is encountered.",
      "When popping, also pop from the min stack if the popped value equals the current minimum. The top of the min stack always gives the current minimum in O(1)."
    ],
    "solutionExplanation": "Use two stacks: one for values and one for tracking minimums. Push to the min stack only when the value is <= current minimum. Time: O(1) per operation, Space: O(n).",
    "optimalCode": "def minStack(operations: list[str], arguments: list[list]) -> list:\n    stack = []\n    min_stack = []\n    results = []\n    for op, args in zip(operations, arguments):\n        if op == 'push':\n            val = args[0]\n            stack.append(val)\n            if not min_stack or val <= min_stack[-1]:\n                min_stack.append(val)\n            results.append(None)\n        elif op == 'pop':\n            val = stack.pop()\n            if val == min_stack[-1]:\n                min_stack.pop()\n            results.append(None)\n        elif op == 'top':\n            results.append(stack[-1])\n        elif op == 'getMin':\n            results.append(min_stack[-1])\n    return results"
  },
  {
    "id": "search-rotated-array",
    "title": "Search in Rotated Sorted Array",
    "difficulty": "Medium",
    "description": "There is an integer array `nums` sorted in ascending order (with distinct values). Prior to being passed to your function, `nums` is possibly rotated at an unknown pivot index.\n\nGiven the array `nums` after the possible rotation and an integer `target`, return the index of `target` if it is in `nums`, or -1 if it is not.\n\nYou must write an algorithm with O(log n) runtime complexity.",
    "examples": [
      {
        "input": "nums = [4,5,6,7,0,1,2], target = 0",
        "output": "4",
        "explanation": null
      },
      {
        "input": "nums = [4,5,6,7,0,1,2], target = 3",
        "output": "-1",
        "explanation": null
      },
      {
        "input": "nums = [1], target = 0",
        "output": "-1",
        "explanation": null
      }
    ],
    "functionSignature": "def search(nums: list[int], target: int) -> int:",
    "starterCode": "def search(nums: list[int], target: int) -> int:\n    # Write your solution here\n    pass",
    "tags": [
      "Binary Search",
      "Arrays"
    ],
    "hints": [
      "This is a modified binary search where you need to identify which half of the array is sorted.",
      "At each step, determine which half is sorted by comparing the mid element with the left or right boundary. Then check if the target falls within the sorted half.",
      "If the target is in the sorted half, narrow the search there. Otherwise, search the other half. Be careful with equal comparisons at boundaries."
    ],
    "solutionExplanation": "Modified binary search: determine which half is sorted, then check if the target lies in that sorted half. Narrow the search accordingly. Time: O(log n), Space: O(1).",
    "optimalCode": "def search(nums: list[int], target: int) -> int:\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        if nums[left] <= nums[mid]:\n            if nums[left] <= target < nums[mid]:\n                right = mid - 1\n            else:\n                left = mid + 1\n        else:\n            if nums[mid] < target <= nums[right]:\n                left = mid + 1\n            else:\n                right = mid - 1\n    return -1"
  },
  {
    "id": "merge-intervals",
    "title": "Merge Intervals",
    "difficulty": "Medium",
    "description": "Given an array of `intervals` where `intervals[i] = [start_i, end_i]`, merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.",
    "examples": [
      {
        "input": "intervals = [[1,3],[2,6],[8,10],[15,18]]",
        "output": "[[1,6],[8,10],[15,18]]",
        "explanation": "Since intervals [1,3] and [2,6] overlap, merge them into [1,6]."
      },
      {
        "input": "intervals = [[1,4],[4,5]]",
        "output": "[[1,5]]",
        "explanation": "Intervals [1,4] and [4,5] are considered overlapping."
      }
    ],
    "functionSignature": "def merge(intervals: list[list[int]]) -> list[list[int]]:",
    "starterCode": "def merge(intervals: list[list[int]]) -> list[list[int]]:\n    # Write your solution here\n    pass",
    "tags": [
      "Arrays",
      "Sorting"
    ],
    "hints": [
      "Sort the intervals by their start time first.",
      "Iterate through sorted intervals; if the current interval overlaps with the previous one (current start <= previous end), merge them by updating the end to max of both ends.",
      "Keep a result list. An interval overlaps with the last merged interval if its start is less than or equal to the last merged interval's end."
    ],
    "solutionExplanation": "Sort intervals by start time. Iterate and merge overlapping intervals by comparing the current start with the previous end. Time: O(n log n), Space: O(n).",
    "optimalCode": "def merge(intervals: list[list[int]]) -> list[list[int]]:\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for start, end in intervals[1:]:\n        if start <= merged[-1][1]:\n            merged[-1][1] = max(merged[-1][1], end)\n        else:\n            merged.append([start, end])\n    return merged"
  },
  {
    "id": "remove-duplicates-sorted",
    "title": "Remove Duplicates from Sorted Array",
    "difficulty": "Medium",
    "description": "Given an integer array `nums` sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same.\n\nReturn the number of unique elements in `nums`.",
    "examples": [
      {
        "input": "nums = [1,1,2]",
        "output": "2",
        "explanation": "Your function should return k = 2, with the first two elements of nums being 1 and 2."
      },
      {
        "input": "nums = [0,0,1,1,1,2,2,3,3,4]",
        "output": "5",
        "explanation": "Your function should return k = 5, with the first five elements being 0, 1, 2, 3, and 4."
      }
    ],
    "functionSignature": "def removeDuplicates(nums: list[int]) -> int:",
    "starterCode": "def removeDuplicates(nums: list[int]) -> int:\n    # Write your solution here\n    pass",
    "tags": [
      "Arrays",
      "Two Pointers"
    ],
    "hints": [
      "Since the array is sorted, duplicates will be adjacent. Use two pointers to solve this in-place.",
      "Use a slow pointer for the write position and a fast pointer to scan. When the fast pointer finds a new value, write it at the slow pointer position.",
      "Start the slow pointer at index 1 (first element is always unique). Compare each element with the previous unique element, not with its adjacent element."
    ],
    "solutionExplanation": "Use a slow pointer for the write position and a fast pointer to scan. Write unique elements at the slow pointer position. Time: O(n), Space: O(1).",
    "optimalCode": "def removeDuplicates(nums: list[int]) -> int:\n    if not nums:\n        return 0\n    write = 1\n    for read in range(1, len(nums)):\n        if nums[read] != nums[write - 1]:\n            nums[write] = nums[read]\n            write += 1\n    return write"
  },
  {
    "id": "longest-substring-no-repeat",
    "title": "Longest Substring Without Repeating Characters",
    "difficulty": "Medium",
    "description": "Given a string `s`, find the length of the longest substring without repeating characters.",
    "examples": [
      {
        "input": "s = \"abcabcbb\"",
        "output": "3",
        "explanation": "The answer is \"abc\", with the length of 3."
      },
      {
        "input": "s = \"bbbbb\"",
        "output": "1",
        "explanation": "The answer is \"b\", with the length of 1."
      },
      {
        "input": "s = \"pwwkew\"",
        "output": "3",
        "explanation": "The answer is \"wke\", with the length of 3."
      }
    ],
    "functionSignature": "def lengthOfLongestSubstring(s: str) -> int:",
    "starterCode": "def lengthOfLongestSubstring(s: str) -> int:\n    # Write your solution here\n    pass",
    "tags": [
      "Strings",
      "Sliding Window",
      "Hash Map"
    ],
    "hints": [
      "Consider using a sliding window approach with a set or hash map to track characters in the current window.",
      "Expand the window by moving the right pointer. When a duplicate is found, shrink from the left until the duplicate is removed.",
      "For optimization, use a hash map storing each character's last index. When a duplicate is found, jump the left pointer directly past the previous occurrence."
    ],
    "solutionExplanation": "Use a sliding window with a hash set. Expand the right boundary, and shrink from the left when a duplicate is found. Track the maximum window size. Time: O(n), Space: O(min(n, alphabet)).",
    "optimalCode": "def lengthOfLongestSubstring(s: str) -> int:\n    char_index = {}\n    left = 0\n    max_len = 0\n    for right in range(len(s)):\n        if s[right] in char_index and char_index[s[right]] >= left:\n            left = char_index[s[right]] + 1\n        char_index[s[right]] = right\n        max_len = max(max_len, right - left + 1)\n    return max_len"
  },
  {
    "id": "best-time-buy-sell-stock-ii",
    "title": "Best Time to Buy and Sell Stock II",
    "difficulty": "Medium",
    "description": "You are given an integer array `prices` where `prices[i]` is the price of a given stock on the ith day.\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\n\nFind and return the maximum profit you can achieve.",
    "examples": [
      {
        "input": "prices = [7,1,5,3,6,4]",
        "output": "7",
        "explanation": "Buy on day 2 (price=1), sell day 3 (price=5), profit=4. Then buy day 4 (price=3), sell day 5 (price=6), profit=3. Total=7."
      },
      {
        "input": "prices = [1,2,3,4,5]",
        "output": "4",
        "explanation": "Buy on day 1 (price=1), sell on day 5 (price=5), profit=4."
      },
      {
        "input": "prices = [7,6,4,3,1]",
        "output": "0",
        "explanation": "No profitable transaction possible."
      }
    ],
    "functionSignature": "def maxProfitII(prices: list[int]) -> int:",
    "starterCode": "def maxProfitII(prices: list[int]) -> int:\n    # Write your solution here\n    pass",
    "tags": [
      "Greedy",
      "Arrays"
    ],
    "hints": [
      "Unlike the single-transaction version, you can make multiple transactions here.",
      "Think greedily: capture every upward price movement. If tomorrow's price is higher than today's, buy today and sell tomorrow.",
      "Sum up all positive differences between consecutive days. This is equivalent to capturing every profitable transaction, no matter how small."
    ],
    "solutionExplanation": "Greedy approach: add up all positive price differences between consecutive days. Every profitable day-to-day increase contributes to the total. Time: O(n), Space: O(1).",
    "optimalCode": "def maxProfitII(prices: list[int]) -> int:\n    profit = 0\n    for i in range(1, len(prices)):\n        if prices[i] > prices[i - 1]:\n            profit += prices[i] - prices[i - 1]\n    return profit"
  },
  {
    "id": "rotate-array",
    "title": "Rotate Array",
    "difficulty": "Medium",
    "description": "Given an integer array `nums`, rotate the array to the right by `k` steps, where `k` is non-negative. Return the rotated array.",
    "examples": [
      {
        "input": "nums = [1,2,3,4,5,6,7], k = 3",
        "output": "[5,6,7,1,2,3,4]",
        "explanation": "Rotate 1 step: [7,1,2,3,4,5,6]. Rotate 2 steps: [6,7,1,2,3,4,5]. Rotate 3 steps: [5,6,7,1,2,3,4]."
      },
      {
        "input": "nums = [-1,-100,3,99], k = 2",
        "output": "[3,99,-1,-100]",
        "explanation": null
      }
    ],
    "functionSignature": "def rotate(nums: list[int], k: int) -> list[int]:",
    "starterCode": "def rotate(nums: list[int], k: int) -> list[int]:\n    # Rotate in-place and return nums\n    pass",
    "tags": [
      "Arrays",
      "Math"
    ],
    "hints": [
      "Think about the relationship between reversing parts of the array and rotation.",
      "The trick is three reversals: reverse the entire array, then reverse the first k elements, then reverse the remaining elements.",
      "Remember to use k % n to handle cases where k is larger than the array length. Each reversal can be done in-place with two pointers."
    ],
    "solutionExplanation": "Reverse the entire array, then reverse the first k elements, then reverse the remaining. Use k % n to handle k larger than array length. Time: O(n), Space: O(1).",
    "optimalCode": "def rotate(nums: list[int], k: int) -> list[int]:\n    n = len(nums)\n    k = k % n\n    def reverse(start, end):\n        while start < end:\n            nums[start], nums[end] = nums[end], nums[start]\n            start += 1\n            end -= 1\n    reverse(0, n - 1)\n    reverse(0, k - 1)\n    reverse(k, n - 1)\n    return nums"
  },
  {
    "id": "pow-x-n",
    "title": "Pow(x, n)",
    "difficulty": "Medium",
    "description": "Implement `pow(x, n)`, which calculates `x` raised to the power `n` (i.e., x^n).",
    "examples": [
      {
        "input": "x = 2.0, n = 10",
        "output": "1024.0",
        "explanation": null
      },
      {
        "input": "x = 2.1, n = 3",
        "output": "9.261",
        "explanation": null
      },
      {
        "input": "x = 2.0, n = -2",
        "output": "0.25",
        "explanation": "2^-2 = 1/(2^2) = 1/4 = 0.25"
      }
    ],
    "functionSignature": "def myPow(x: float, n: int) -> float:",
    "starterCode": "def myPow(x: float, n: int) -> float:\n    # Write your solution here\n    pass",
    "tags": [
      "Math",
      "Recursion"
    ],
    "hints": [
      "Think about how squaring the base and halving the exponent can speed things up (binary exponentiation).",
      "If n is even, x^n = (x^2)^(n/2). If n is odd, x^n = x * x^(n-1). This reduces the exponent logarithmically.",
      "Handle negative exponents by computing 1 / x^(-n). Be careful with the edge case when n is the minimum integer value, as negating it can cause overflow."
    ],
    "solutionExplanation": "Use fast exponentiation (binary exponentiation). Square the base and halve the exponent at each step. Handle negative exponents by inverting. Time: O(log n), Space: O(1).",
    "optimalCode": "def myPow(x: float, n: int) -> float:\n    if n < 0:\n        x = 1 / x\n        n = -n\n    result = 1.0\n    while n > 0:\n        if n % 2 == 1:\n            result *= x\n        x *= x\n        n //= 2\n    return round(result, 3)"
  },
  {
    "id": "spiral-matrix",
    "title": "Spiral Matrix",
    "difficulty": "Hard",
    "description": "Given an `m x n` matrix, return all elements of the matrix in spiral order.",
    "examples": [
      {
        "input": "matrix = [[1,2,3],[4,5,6],[7,8,9]]",
        "output": "[1,2,3,6,9,8,7,4,5]",
        "explanation": null
      },
      {
        "input": "matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]",
        "output": "[1,2,3,4,8,12,11,10,9,5,6,7]",
        "explanation": null
      }
    ],
    "functionSignature": "def spiralOrder(matrix: list[list[int]]) -> list[int]:",
    "starterCode": "def spiralOrder(matrix: list[list[int]]) -> list[int]:\n    # Write your solution here\n    pass",
    "tags": [
      "Arrays",
      "Matrix"
    ],
    "hints": [
      "Think about maintaining four boundaries (top, bottom, left, right) that shrink as you traverse.",
      "Traverse in order: left to right along top row, top to bottom along right column, right to left along bottom row, bottom to top along left column. Shrink the corresponding boundary after each traversal.",
      "After each direction, check if the boundaries are still valid before proceeding to the next direction. This handles non-square matrices correctly."
    ],
    "solutionExplanation": "Simulate the spiral by maintaining four boundaries (top, bottom, left, right). Traverse right, down, left, up and shrink boundaries after each direction. Time: O(m*n), Space: O(1).",
    "optimalCode": "def spiralOrder(matrix: list[list[int]]) -> list[int]:\n    result = []\n    top, bottom, left, right = 0, len(matrix) - 1, 0, len(matrix[0]) - 1\n    while top <= bottom and left <= right:\n        for i in range(left, right + 1):\n            result.append(matrix[top][i])\n        top += 1\n        for i in range(top, bottom + 1):\n            result.append(matrix[i][right])\n        right -= 1\n        if top <= bottom:\n            for i in range(right, left - 1, -1):\n                result.append(matrix[bottom][i])\n            bottom -= 1\n        if left <= right:\n            for i in range(bottom, top - 1, -1):\n                result.append(matrix[i][left])\n            left += 1\n    return result"
  },
  {
    "id": "word-search",
    "title": "Word Search",
    "difficulty": "Hard",
    "description": "Given an `m x n` grid of characters `board` and a string `word`, return `true` if `word` exists in the grid.\n\nThe word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.",
    "examples": [
      {
        "input": "board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCCED\"",
        "output": "true",
        "explanation": null
      },
      {
        "input": "board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"SEE\"",
        "output": "true",
        "explanation": null
      },
      {
        "input": "board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCB\"",
        "output": "false",
        "explanation": null
      }
    ],
    "functionSignature": "def exist(board: list[list[str]], word: str) -> bool:",
    "starterCode": "def exist(board: list[list[str]], word: str) -> bool:\n    # Write your solution here\n    pass",
    "tags": [
      "Arrays",
      "Backtracking",
      "Matrix"
    ],
    "hints": [
      "Use backtracking (DFS) starting from each cell that matches the first character of the word.",
      "At each step, mark the current cell as visited, then explore all four adjacent cells for the next character. Restore the cell after backtracking.",
      "Prune early: before starting DFS, count character frequencies in the board and word to quickly reject impossible cases. Also, if the last character is rarer than the first, search the word in reverse."
    ],
    "solutionExplanation": "Use backtracking DFS from each cell. Mark visited cells to avoid reuse, and restore them after backtracking. Time: O(m*n*4^L) where L is word length, Space: O(L).",
    "optimalCode": "def exist(board: list[list[str]], word: str) -> bool:\n    rows, cols = len(board), len(board[0])\n    def dfs(r, c, idx):\n        if idx == len(word):\n            return True\n        if r < 0 or r >= rows or c < 0 or c >= cols or board[r][c] != word[idx]:\n            return False\n        temp = board[r][c]\n        board[r][c] = '#'\n        found = (dfs(r + 1, c, idx + 1) or dfs(r - 1, c, idx + 1) or\n                 dfs(r, c + 1, idx + 1) or dfs(r, c - 1, idx + 1))\n        board[r][c] = temp\n        return found\n    for r in range(rows):\n        for c in range(cols):\n            if dfs(r, c, 0):\n                return True\n    return False"
  },
  {
    "id": "trapping-rain-water",
    "title": "Trapping Rain Water",
    "difficulty": "Hard",
    "description": "Given `n` non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.",
    "examples": [
      {
        "input": "height = [0,1,0,2,1,0,1,3,2,1,2,1]",
        "output": "6",
        "explanation": "6 units of rain water are trapped."
      },
      {
        "input": "height = [4,2,0,3,2,5]",
        "output": "9",
        "explanation": null
      }
    ],
    "functionSignature": "def trap(height: list[int]) -> int:",
    "starterCode": "def trap(height: list[int]) -> int:\n    # Write your solution here\n    pass",
    "tags": [
      "Arrays",
      "Two Pointers",
      "Dynamic Programming"
    ],
    "hints": [
      "Water at each position depends on the minimum of the maximum heights to its left and right.",
      "Use two pointers from both ends, tracking the maximum height seen from each side.",
      "Move the pointer with the smaller maximum inward. The water at that position is the difference between the smaller maximum and the current height. This works because the other side is guaranteed to be at least as tall."
    ],
    "solutionExplanation": "Use two pointers from both ends tracking left_max and right_max. Water at each position equals min(left_max, right_max) - height. Move the pointer with the smaller max. Time: O(n), Space: O(1).",
    "optimalCode": "def trap(height: list[int]) -> int:\n    left, right = 0, len(height) - 1\n    left_max, right_max = 0, 0\n    water = 0\n    while left < right:\n        if height[left] < height[right]:\n            if height[left] >= left_max:\n                left_max = height[left]\n            else:\n                water += left_max - height[left]\n            left += 1\n        else:\n            if height[right] >= right_max:\n                right_max = height[right]\n            else:\n                water += right_max - height[right]\n            right -= 1\n    return water"
  },
  {
    "id": "longest-palindromic-substring",
    "title": "Longest Palindromic Substring",
    "difficulty": "Hard",
    "description": "Given a string `s`, return the longest palindromic substring in `s`.",
    "examples": [
      {
        "input": "s = \"babad\"",
        "output": "\"bab\"",
        "explanation": "\"aba\" is also a valid answer."
      },
      {
        "input": "s = \"cbbd\"",
        "output": "\"bb\"",
        "explanation": null
      }
    ],
    "functionSignature": "def longestPalindrome(s: str) -> str:",
    "starterCode": "def longestPalindrome(s: str) -> str:\n    # Write your solution here\n    pass",
    "tags": [
      "Strings",
      "Dynamic Programming"
    ],
    "hints": [
      "A palindrome mirrors around its center. Consider expanding around each possible center.",
      "For each index, try expanding outward from that index (odd-length palindromes) and from between that index and the next (even-length palindromes).",
      "Track the start and length of the longest palindrome found. Expanding stops when characters no longer match or boundaries are reached."
    ],
    "solutionExplanation": "Expand around each center (both single character and between characters). Track the longest palindrome found. Time: O(n²), Space: O(1).",
    "optimalCode": "def longestPalindrome(s: str) -> str:\n    start, max_len = 0, 1\n    def expand(left, right):\n        nonlocal start, max_len\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            if right - left + 1 > max_len:\n                start = left\n                max_len = right - left + 1\n            left -= 1\n            right += 1\n    for i in range(len(s)):\n        expand(i, i)\n        expand(i, i + 1)\n    return s[start:start + max_len]"
  },
  {
    "id": "majority-element",
    "title": "Majority Element",
    "difficulty": "Easy",
    "description": "Given an array `nums` of size `n`, return the majority element.\n\nThe majority element is the element that appears more than n/2 times. You may assume that the majority element always exists in the array.",
    "examples": [
      {
        "input": "nums = [3,2,3]",
        "output": "3",
        "explanation": null
      },
      {
        "input": "nums = [2,2,1,1,1,2,2]",
        "output": "2",
        "explanation": null
      }
    ],
    "functionSignature": "def majorityElement(nums: list[int]) -> int:",
    "starterCode": "def majorityElement(nums: list[int]) -> int:\n    # Write your solution here\n    pass",
    "tags": [
      "Arrays",
      "Hash Map"
    ],
    "hints": [
      "Think about Boyer-Moore Voting Algorithm, which finds the majority element in a single pass.",
      "Maintain a candidate and a count. For each element, if count is 0, set the current element as candidate. Increment count if the element matches the candidate, decrement otherwise.",
      "This works because the majority element appears more than n/2 times, so it will always survive the counting process. The final candidate is the majority element."
    ],
    "solutionExplanation": "Boyer-Moore Voting Algorithm: maintain a candidate and count. Increment for same element, decrement for different. The candidate after one pass is the majority element. Time: O(n), Space: O(1).",
    "optimalCode": "def majorityElement(nums: list[int]) -> int:\n    candidate = None\n    count = 0\n    for num in nums:\n        if count == 0:\n            candidate = num\n        count += 1 if num == candidate else -1\n    return candidate"
  },
  {
    "id": "happy-number",
    "title": "Happy Number",
    "difficulty": "Easy",
    "description": "Write an algorithm to determine if a number `n` is happy.\n\nA happy number is defined by replacing the number by the sum of the squares of its digits, and repeating until the number equals 1 (where it stays), or it loops endlessly in a cycle which does not include 1.\n\nReturn `true` if `n` is a happy number, `false` otherwise.",
    "examples": [
      {
        "input": "n = 19",
        "output": "true",
        "explanation": "1² + 9² = 82, 8² + 2² = 68, 6² + 8² = 100, 1² + 0² + 0² = 1."
      },
      {
        "input": "n = 2",
        "output": "false",
        "explanation": null
      }
    ],
    "functionSignature": "def isHappy(n: int) -> bool:",
    "starterCode": "def isHappy(n: int) -> bool:\n    # Write your solution here\n    pass",
    "tags": [
      "Math",
      "Hash Map"
    ],
    "hints": [
      "Repeatedly replace the number with the sum of the squares of its digits. Detect if you enter a cycle.",
      "Use a set to track numbers you've already seen. If a number repeats, you're in a cycle and it's not happy.",
      "For O(1) space, use Floyd's cycle detection (tortoise and hare): compute the digit-square-sum at two different speeds. If the fast one reaches 1, it's happy; if they meet at another number, it's not."
    ],
    "solutionExplanation": "Use Floyd's cycle detection (fast/slow pointers) or a hash set to detect cycles. Repeatedly sum squares of digits until reaching 1 or detecting a cycle. Time: O(log n), Space: O(1) with Floyd's.",
    "optimalCode": "def isHappy(n: int) -> bool:\n    seen = set()\n    while n != 1:\n        n = sum(int(d) ** 2 for d in str(n))\n        if n in seen:\n            return False\n        seen.add(n)\n    return True"
  },
  {
    "id": "power-of-three",
    "title": "Power of Three",
    "difficulty": "Easy",
    "description": "Given an integer `n`, return `true` if it is a power of three. Otherwise, return `false`.\n\nAn integer `n` is a power of three, if there exists an integer `x` such that n == 3^x.",
    "examples": [
      {
        "input": "n = 27",
        "output": "true",
        "explanation": "27 = 3³"
      },
      {
        "input": "n = 0",
        "output": "false",
        "explanation": null
      },
      {
        "input": "n = -1",
        "output": "false",
        "explanation": null
      }
    ],
    "functionSignature": "def isPowerOfThree(n: int) -> bool:",
    "starterCode": "def isPowerOfThree(n: int) -> bool:\n    # Write your solution here\n    pass",
    "tags": [
      "Math"
    ],
    "hints": [
      "Consider repeatedly dividing by 3 and checking if you reach exactly 1.",
      "While n is divisible by 3, divide by 3. If the result is 1, it's a power of three. Make sure n > 0 first.",
      "A mathematical trick: 3^19 = 1162261467 is the largest power of 3 fitting in a 32-bit integer. Check if n > 0 and 1162261467 % n == 0."
    ],
    "solutionExplanation": "Repeatedly divide by 3 while divisible. If the result is 1, it's a power of three. Alternatively, check if 3^19 (largest power of 3 in int range) is divisible by n. Time: O(log n), Space: O(1).",
    "optimalCode": "def isPowerOfThree(n: int) -> bool:\n    if n <= 0:\n        return False\n    while n % 3 == 0:\n        n //= 3\n    return n == 1"
  },
  {
    "id": "merge-sorted-array",
    "title": "Merge Sorted Array",
    "difficulty": "Easy",
    "description": "You are given two integer arrays `nums1` and `nums2`, sorted in non-decreasing order, and two integers `m` and `n`, representing the number of elements in `nums1` and `nums2` respectively.\n\nMerge `nums2` into `nums1` as one sorted array. The final sorted array should not be returned by the function, but instead be stored inside the array `nums1`. `nums1` has a length of `m + n`, where the last `n` elements are set to 0 and should be ignored.\n\nReturn the merged array.",
    "examples": [
      {
        "input": "nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3",
        "output": "[1,2,2,3,5,6]",
        "explanation": null
      },
      {
        "input": "nums1 = [1], m = 1, nums2 = [], n = 0",
        "output": "[1]",
        "explanation": null
      }
    ],
    "functionSignature": "def mergeSortedArray(nums1: list[int], m: int, nums2: list[int], n: int) -> list[int]:",
    "starterCode": "def mergeSortedArray(nums1: list[int], m: int, nums2: list[int], n: int) -> list[int]:\n    # Merge in-place and return nums1\n    pass",
    "tags": [
      "Arrays",
      "Two Pointers",
      "Sorting"
    ],
    "hints": [
      "Think about filling nums1 from the back to avoid overwriting elements you still need.",
      "Use three pointers: one at position m-1 in nums1, one at position n-1 in nums2, and one at position m+n-1 for where to write.",
      "Compare elements from both arrays and place the larger one at the write position, moving backwards. If nums2 has remaining elements after nums1 is exhausted, copy them over."
    ],
    "solutionExplanation": "Start from the end of both arrays and work backwards, placing the larger element at the end of nums1. This avoids overwriting elements. Time: O(n + m), Space: O(1).",
    "optimalCode": "def mergeSortedArray(nums1: list[int], m: int, nums2: list[int], n: int) -> list[int]:\n    p1, p2, p = m - 1, n - 1, m + n - 1\n    while p2 >= 0:\n        if p1 >= 0 and nums1[p1] > nums2[p2]:\n            nums1[p] = nums1[p1]\n            p1 -= 1\n        else:\n            nums1[p] = nums2[p2]\n            p2 -= 1\n        p -= 1\n    return nums1"
  },
  {
    "id": "remove-element",
    "title": "Remove Element",
    "difficulty": "Easy",
    "description": "Given an integer array `nums` and an integer `val`, remove all occurrences of `val` in `nums` in-place. The order of the elements may be changed.\n\nReturn the number of elements in `nums` which are not equal to `val`.",
    "examples": [
      {
        "input": "nums = [3,2,2,3], val = 3",
        "output": "2",
        "explanation": "Your function should return k = 2, with the first two elements of nums being 2 and 2."
      },
      {
        "input": "nums = [0,1,2,2,3,0,4,2], val = 2",
        "output": "5",
        "explanation": "Your function should return k = 5, with the first five elements being 0, 1, 3, 0, and 4."
      }
    ],
    "functionSignature": "def removeElement(nums: list[int], val: int) -> int:",
    "starterCode": "def removeElement(nums: list[int], val: int) -> int:\n    # Write your solution here\n    pass",
    "tags": [
      "Arrays",
      "Two Pointers"
    ],
    "hints": [
      "Use a two-pointer approach where one pointer reads and the other writes.",
      "The write pointer only advances when the read pointer encounters a value that is not equal to val.",
      "Copy non-target values to the write position. The write pointer at the end gives you the count of remaining elements. The order of remaining elements may change."
    ],
    "solutionExplanation": "Use two pointers: read and write positions. Copy non-target elements to the write position. Return the write pointer as the new length. Time: O(n), Space: O(1).",
    "optimalCode": "def removeElement(nums: list[int], val: int) -> int:\n    write = 0\n    for read in range(len(nums)):\n        if nums[read] != val:\n            nums[write] = nums[read]\n            write += 1\n    return write"
  },
  {
    "id": "excel-column-number",
    "title": "Excel Sheet Column Number",
    "difficulty": "Easy",
    "description": "Given a string `columnTitle` that represents the column title as appears in an Excel sheet, return its corresponding column number.\n\nFor example: A -> 1, B -> 2, ..., Z -> 26, AA -> 27, AB -> 28, ...",
    "examples": [
      {
        "input": "columnTitle = \"A\"",
        "output": "1",
        "explanation": null
      },
      {
        "input": "columnTitle = \"AB\"",
        "output": "28",
        "explanation": null
      },
      {
        "input": "columnTitle = \"ZY\"",
        "output": "701",
        "explanation": null
      }
    ],
    "functionSignature": "def titleToNumber(columnTitle: str) -> int:",
    "starterCode": "def titleToNumber(columnTitle: str) -> int:\n    # Write your solution here\n    pass",
    "tags": [
      "Math",
      "Strings"
    ],
    "hints": [
      "Think of the column title as a base-26 number where A=1, B=2, ..., Z=26.",
      "Process characters from left to right, multiplying the running result by 26 before adding the current character's value.",
      "Convert each character to its value using: ord(char) - ord('A') + 1. This gives A=1, B=2, etc."
    ],
    "solutionExplanation": "Treat it as a base-26 number. Iterate through characters, multiplying the result by 26 and adding the current character's value (A=1, B=2, etc.). Time: O(n), Space: O(1).",
    "optimalCode": "def titleToNumber(columnTitle: str) -> int:\n    result = 0\n    for c in columnTitle:\n        result = result * 26 + (ord(c) - ord('A') + 1)\n    return result"
  },
  {
    "id": "intersection-two-arrays",
    "title": "Intersection of Two Arrays II",
    "difficulty": "Easy",
    "description": "Given two integer arrays `nums1` and `nums2`, return an array of their intersection. Each element in the result must appear as many times as it shows in both arrays. You may return the result in any order.",
    "examples": [
      {
        "input": "nums1 = [1,2,2,1], nums2 = [2,2]",
        "output": "[2,2]",
        "explanation": null
      },
      {
        "input": "nums1 = [4,9,5], nums2 = [9,4,9,8,4]",
        "output": "[4,9]",
        "explanation": "or [9,4] is also accepted."
      }
    ],
    "functionSignature": "def intersect(nums1: list[int], nums2: list[int]) -> list[int]:",
    "starterCode": "def intersect(nums1: list[int], nums2: list[int]) -> list[int]:\n    # Write your solution here\n    pass",
    "tags": [
      "Arrays",
      "Hash Map",
      "Sorting"
    ],
    "hints": [
      "Think about using a hash map to count element frequencies in one array.",
      "Build a frequency counter for the smaller array, then iterate through the larger array, collecting matches and decrementing counts.",
      "Each time you find a match, decrement the count so elements are not used more times than they appear. If the arrays were sorted, you could use a two-pointer approach instead."
    ],
    "solutionExplanation": "Use a Counter/hash map on one array, then iterate the other, decrementing counts for matches. Time: O(n + m), Space: O(min(n, m)).",
    "optimalCode": "def intersect(nums1: list[int], nums2: list[int]) -> list[int]:\n    count = {}\n    for num in nums1:\n        count[num] = count.get(num, 0) + 1\n    result = []\n    for num in nums2:\n        if count.get(num, 0) > 0:\n            result.append(num)\n            count[num] -= 1\n    return result"
  },
  {
    "id": "add-binary",
    "title": "Add Binary",
    "difficulty": "Easy",
    "description": "Given two binary strings `a` and `b`, return their sum as a binary string.",
    "examples": [
      {
        "input": "a = \"11\", b = \"1\"",
        "output": "\"100\"",
        "explanation": null
      },
      {
        "input": "a = \"1010\", b = \"1011\"",
        "output": "\"10101\"",
        "explanation": null
      }
    ],
    "functionSignature": "def addBinary(a: str, b: str) -> str:",
    "starterCode": "def addBinary(a: str, b: str) -> str:\n    # Write your solution here\n    pass",
    "tags": [
      "Math",
      "Strings",
      "Bit Manipulation"
    ],
    "hints": [
      "Process both strings from right to left, adding corresponding digits along with a carry.",
      "At each position, sum the two digits and the carry. The result digit is sum % 2, and the new carry is sum / 2.",
      "Don't forget to handle the final carry after processing all digits. Also handle strings of different lengths by treating missing digits as 0."
    ],
    "solutionExplanation": "Iterate both strings from the end, adding digits with carry. Build the result string in reverse. Time: O(max(n, m)), Space: O(max(n, m)).",
    "optimalCode": "def addBinary(a: str, b: str) -> str:\n    result = []\n    carry = 0\n    i, j = len(a) - 1, len(b) - 1\n    while i >= 0 or j >= 0 or carry:\n        total = carry\n        if i >= 0:\n            total += int(a[i])\n            i -= 1\n        if j >= 0:\n            total += int(b[j])\n            j -= 1\n        result.append(str(total % 2))\n        carry = total // 2\n    return ''.join(reversed(result))"
  },
  {
    "id": "sqrt-x",
    "title": "Sqrt(x)",
    "difficulty": "Easy",
    "description": "Given a non-negative integer `x`, return the square root of `x` rounded down to the nearest integer. The returned integer should be non-negative as well.\n\nYou must not use any built-in exponent function or operator (like `**` or `pow`).",
    "examples": [
      {
        "input": "x = 4",
        "output": "2",
        "explanation": null
      },
      {
        "input": "x = 8",
        "output": "2",
        "explanation": "The square root of 8 is 2.828..., rounded down to 2."
      }
    ],
    "functionSignature": "def mySqrt(x: int) -> int:",
    "starterCode": "def mySqrt(x: int) -> int:\n    # Write your solution here (without using ** or pow)\n    pass",
    "tags": [
      "Binary Search",
      "Math"
    ],
    "hints": [
      "Use binary search to find the largest integer whose square is less than or equal to x.",
      "Search in the range [0, x]. For each mid value, check if mid * mid <= x and (mid+1) * (mid+1) > x.",
      "To avoid integer overflow when computing mid * mid, you can compare mid with x / mid instead, or use a language with big integers."
    ],
    "solutionExplanation": "Use binary search between 0 and x to find the largest integer whose square is <= x. Time: O(log x), Space: O(1).",
    "optimalCode": "def mySqrt(x: int) -> int:\n    if x < 2:\n        return x\n    left, right = 1, x // 2\n    while left <= right:\n        mid = (left + right) // 2\n        if mid * mid == x:\n            return mid\n        elif mid * mid < x:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return right"
  },
  {
    "id": "top-k-frequent",
    "title": "Top K Frequent Elements",
    "difficulty": "Medium",
    "description": "Given an integer array `nums` and an integer `k`, return the `k` most frequent elements. You may return the answer in any order.",
    "examples": [
      {
        "input": "nums = [1,1,1,2,2,3], k = 2",
        "output": "[1,2]",
        "explanation": null
      },
      {
        "input": "nums = [1], k = 1",
        "output": "[1]",
        "explanation": null
      }
    ],
    "functionSignature": "def topKFrequent(nums: list[int], k: int) -> list[int]:",
    "starterCode": "def topKFrequent(nums: list[int], k: int) -> list[int]:\n    # Write your solution here\n    pass",
    "tags": [
      "Arrays",
      "Hash Map",
      "Sorting"
    ],
    "hints": [
      "First count the frequency of each element using a hash map.",
      "Use bucket sort where the index represents frequency. Create an array of size n+1 where bucket[i] contains elements that appear i times.",
      "Iterate through the buckets from highest to lowest frequency, collecting elements until you have k elements. This gives O(n) time complexity."
    ],
    "solutionExplanation": "Count frequencies with a hash map, then use bucket sort or a heap to get the top k elements. Bucket sort groups elements by frequency for O(n) time. Time: O(n), Space: O(n).",
    "optimalCode": "def topKFrequent(nums: list[int], k: int) -> list[int]:\n    count = {}\n    for num in nums:\n        count[num] = count.get(num, 0) + 1\n    buckets = [[] for _ in range(len(nums) + 1)]\n    for num, freq in count.items():\n        buckets[freq].append(num)\n    result = []\n    for i in range(len(buckets) - 1, -1, -1):\n        for num in buckets[i]:\n            result.append(num)\n            if len(result) == k:\n                return result\n    return result"
  },
  {
    "id": "subsets",
    "title": "Subsets",
    "difficulty": "Medium",
    "description": "Given an integer array `nums` of unique elements, return all possible subsets (the power set).\n\nThe solution set must not contain duplicate subsets. Return the solution in any order.",
    "examples": [
      {
        "input": "nums = [1,2,3]",
        "output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
        "explanation": null
      },
      {
        "input": "nums = [0]",
        "output": "[[],[0]]",
        "explanation": null
      }
    ],
    "functionSignature": "def subsets(nums: list[int]) -> list[list[int]]:",
    "starterCode": "def subsets(nums: list[int]) -> list[list[int]]:\n    # Write your solution here\n    pass",
    "tags": [
      "Arrays",
      "Backtracking"
    ],
    "hints": [
      "Think about the include/exclude decision for each element -- this is a classic backtracking pattern.",
      "For each element, you have two choices: include it in the current subset or don't. Recurse on the remaining elements.",
      "Alternatively, iterate through existing subsets and for each one, create a new subset by adding the current element. Start with an empty subset."
    ],
    "solutionExplanation": "Use backtracking: at each element, choose to include or exclude it. Alternatively, iterate and for each existing subset, create a new one with the current element added. Time: O(n * 2^n), Space: O(n).",
    "optimalCode": "def subsets(nums: list[int]) -> list[list[int]]:\n    result = [[]]\n    for num in nums:\n        result += [subset + [num] for subset in result]\n    return result"
  },
  {
    "id": "permutations",
    "title": "Permutations",
    "difficulty": "Medium",
    "description": "Given an array `nums` of distinct integers, return all the possible permutations. You can return the answer in any order.",
    "examples": [
      {
        "input": "nums = [1,2,3]",
        "output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
        "explanation": null
      },
      {
        "input": "nums = [0,1]",
        "output": "[[0,1],[1,0]]",
        "explanation": null
      },
      {
        "input": "nums = [1]",
        "output": "[[1]]",
        "explanation": null
      }
    ],
    "functionSignature": "def permute(nums: list[int]) -> list[list[int]]:",
    "starterCode": "def permute(nums: list[int]) -> list[list[int]]:\n    # Write your solution here\n    pass",
    "tags": [
      "Arrays",
      "Backtracking",
      "Recursion"
    ],
    "hints": [
      "Use backtracking: at each position, try placing each unused element.",
      "Maintain a current permutation and a set of used indices. At each recursive step, try each unused element, add it, recurse, then remove it.",
      "Alternatively, use swapping: for position i, swap it with each position from i to n-1, recurse for position i+1, then swap back."
    ],
    "solutionExplanation": "Use backtracking: for each position, try every unused element. Swap elements to build permutations and backtrack by swapping back. Time: O(n * n!), Space: O(n).",
    "optimalCode": "def permute(nums: list[int]) -> list[list[int]]:\n    result = []\n    def backtrack(current, remaining):\n        if not remaining:\n            result.append(current[:])\n            return\n        for i in range(len(remaining)):\n            current.append(remaining[i])\n            backtrack(current, remaining[:i] + remaining[i+1:])\n            current.pop()\n    backtrack([], nums)\n    return result"
  },
  {
    "id": "letter-combinations",
    "title": "Letter Combinations of a Phone Number",
    "difficulty": "Medium",
    "description": "Given a string containing digits from 2-9, return all possible letter combinations that the number could represent. Return the answer in any order.\n\nMapping: 2=abc, 3=def, 4=ghi, 5=jkl, 6=mno, 7=pqrs, 8=tuv, 9=wxyz",
    "examples": [
      {
        "input": "digits = \"23\"",
        "output": "[\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]",
        "explanation": null
      },
      {
        "input": "digits = \"\"",
        "output": "[]",
        "explanation": null
      },
      {
        "input": "digits = \"2\"",
        "output": "[\"a\",\"b\",\"c\"]",
        "explanation": null
      }
    ],
    "functionSignature": "def letterCombinations(digits: str) -> list[str]:",
    "starterCode": "def letterCombinations(digits: str) -> list[str]:\n    # Write your solution here\n    pass",
    "tags": [
      "Strings",
      "Backtracking",
      "Recursion"
    ],
    "hints": [
      "Create a mapping from each digit to its corresponding letters, then build combinations recursively.",
      "Use backtracking: for each digit in the input, try appending each of its possible letters to the current combination.",
      "Handle the empty input case separately (return empty list). The number of combinations grows exponentially (up to 4^n), so there's no way to avoid generating all of them."
    ],
    "solutionExplanation": "Use backtracking or BFS. Map each digit to its letters and build combinations by appending each possible letter for each digit. Time: O(4^n), Space: O(n).",
    "optimalCode": "def letterCombinations(digits: str) -> list[str]:\n    if not digits:\n        return []\n    phone = {'2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'}\n    result = []\n    def backtrack(idx, current):\n        if idx == len(digits):\n            result.append(current)\n            return\n        for letter in phone[digits[idx]]:\n            backtrack(idx + 1, current + letter)\n    backtrack(0, '')\n    return result"
  },
  {
    "id": "generate-parentheses",
    "title": "Generate Parentheses",
    "difficulty": "Medium",
    "description": "Given `n` pairs of parentheses, write a function to generate all combinations of well-formed parentheses.",
    "examples": [
      {
        "input": "n = 3",
        "output": "[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]",
        "explanation": null
      },
      {
        "input": "n = 1",
        "output": "[\"()\"]",
        "explanation": null
      }
    ],
    "functionSignature": "def generateParenthesis(n: int) -> list[str]:",
    "starterCode": "def generateParenthesis(n: int) -> list[str]:\n    # Write your solution here\n    pass",
    "tags": [
      "Strings",
      "Backtracking",
      "Recursion"
    ],
    "hints": [
      "Use backtracking with two counters: one for open parentheses used and one for close parentheses used.",
      "You can add an open parenthesis if the open count is less than n. You can add a close parenthesis if the close count is less than the open count.",
      "The constraint that close < open ensures you never have more closing parentheses than opening ones at any point, guaranteeing well-formed results."
    ],
    "solutionExplanation": "Use backtracking with counts of open and close parentheses. Add open if count < n, add close if close count < open count. Time: O(4^n / sqrt(n)), Space: O(n).",
    "optimalCode": "def generateParenthesis(n: int) -> list[str]:\n    result = []\n    def backtrack(current, open_count, close_count):\n        if len(current) == 2 * n:\n            result.append(current)\n            return\n        if open_count < n:\n            backtrack(current + '(', open_count + 1, close_count)\n        if close_count < open_count:\n            backtrack(current + ')', open_count, close_count + 1)\n    backtrack('', 0, 0)\n    return result"
  },
  {
    "id": "set-matrix-zeroes",
    "title": "Set Matrix Zeroes",
    "difficulty": "Medium",
    "description": "Given an `m x n` integer matrix, if an element is 0, set its entire row and column to 0's.\n\nYou must do it in place. Return the modified matrix.",
    "examples": [
      {
        "input": "matrix = [[1,1,1],[1,0,1],[1,1,1]]",
        "output": "[[1,0,1],[0,0,0],[1,0,1]]",
        "explanation": null
      },
      {
        "input": "matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]",
        "output": "[[0,0,0,0],[0,4,5,0],[0,3,1,0]]",
        "explanation": null
      }
    ],
    "functionSignature": "def setZeroes(matrix: list[list[int]]) -> list[list[int]]:",
    "starterCode": "def setZeroes(matrix: list[list[int]]) -> list[list[int]]:\n    # Modify in-place and return matrix\n    pass",
    "tags": [
      "Arrays",
      "Matrix"
    ],
    "hints": [
      "The challenge is marking which rows and columns to zero without using extra space. Think about using the matrix itself as storage.",
      "Use the first row and first column as markers. If matrix[i][j] is 0, set matrix[i][0] and matrix[0][j] to 0.",
      "Process the matrix in reverse (bottom-right to top-left) when zeroing out to avoid corrupting the markers. Handle the first row and column separately with boolean flags."
    ],
    "solutionExplanation": "Use the first row and column as markers. Scan the matrix to mark which rows and columns contain zeros, then zero out marked rows and columns. Time: O(m*n), Space: O(1).",
    "optimalCode": "def setZeroes(matrix: list[list[int]]) -> list[list[int]]:\n    m, n = len(matrix), len(matrix[0])\n    first_row_zero = any(matrix[0][j] == 0 for j in range(n))\n    first_col_zero = any(matrix[i][0] == 0 for i in range(m))\n    for i in range(1, m):\n        for j in range(1, n):\n            if matrix[i][j] == 0:\n                matrix[i][0] = 0\n                matrix[0][j] = 0\n    for i in range(1, m):\n        for j in range(1, n):\n            if matrix[i][0] == 0 or matrix[0][j] == 0:\n                matrix[i][j] = 0\n    if first_row_zero:\n        for j in range(n):\n            matrix[0][j] = 0\n    if first_col_zero:\n        for i in range(m):\n            matrix[i][0] = 0\n    return matrix"
  },
  {
    "id": "max-product-subarray",
    "title": "Maximum Product Subarray",
    "difficulty": "Medium",
    "description": "Given an integer array `nums`, find a subarray that has the largest product, and return the product.\n\nA subarray is a contiguous non-empty sequence of elements within an array.",
    "examples": [
      {
        "input": "nums = [2,3,-2,4]",
        "output": "6",
        "explanation": "[2,3] has the largest product 6."
      },
      {
        "input": "nums = [-2,0,-1]",
        "output": "0",
        "explanation": "The result cannot be 2, because [-2,-1] is not a subarray."
      }
    ],
    "functionSignature": "def maxProduct(nums: list[int]) -> int:",
    "starterCode": "def maxProduct(nums: list[int]) -> int:\n    # Write your solution here\n    pass",
    "tags": [
      "Arrays",
      "Dynamic Programming"
    ],
    "hints": [
      "Unlike maximum sum, a negative number can become the maximum product if multiplied by another negative number.",
      "Track both the maximum and minimum products ending at each position, since the minimum (most negative) can become the maximum when multiplied by a negative.",
      "At each element, the new max is the max of: current element, current * previous max, current * previous min. Similarly for the new min. Swap max and min when the current element is negative."
    ],
    "solutionExplanation": "Track both the maximum and minimum product ending at each position (minimum can become maximum when multiplied by a negative). Time: O(n), Space: O(1).",
    "optimalCode": "def maxProduct(nums: list[int]) -> int:\n    max_prod = nums[0]\n    cur_max = nums[0]\n    cur_min = nums[0]\n    for i in range(1, len(nums)):\n        if nums[i] < 0:\n            cur_max, cur_min = cur_min, cur_max\n        cur_max = max(nums[i], cur_max * nums[i])\n        cur_min = min(nums[i], cur_min * nums[i])\n        max_prod = max(max_prod, cur_max)\n    return max_prod"
  },
  {
    "id": "find-min-rotated",
    "title": "Find Minimum in Rotated Sorted Array",
    "difficulty": "Medium",
    "description": "Suppose an array of length `n` sorted in ascending order is rotated between 1 and `n` times. Given the sorted rotated array `nums` of unique elements, return the minimum element of this array.\n\nYou must write an algorithm that runs in O(log n) time.",
    "examples": [
      {
        "input": "nums = [3,4,5,1,2]",
        "output": "1",
        "explanation": "The original array was [1,2,3,4,5] rotated 3 times."
      },
      {
        "input": "nums = [4,5,6,7,0,1,2]",
        "output": "0",
        "explanation": null
      },
      {
        "input": "nums = [11,13,15,17]",
        "output": "11",
        "explanation": "The original array was not rotated."
      }
    ],
    "functionSignature": "def findMin(nums: list[int]) -> int:",
    "starterCode": "def findMin(nums: list[int]) -> int:\n    # Write your solution here\n    pass",
    "tags": [
      "Binary Search",
      "Arrays"
    ],
    "hints": [
      "The minimum element is at the rotation point. Use binary search to find it efficiently.",
      "Compare the middle element with the rightmost element. If mid > right, the minimum is in the right half. If mid < right, it's in the left half (including mid).",
      "Shrink the search range accordingly. When left == right, you've found the minimum. Be careful not to exclude mid when it could be the answer."
    ],
    "solutionExplanation": "Use binary search: compare mid with right. If mid > right, the minimum is in the right half. Otherwise, it's in the left half (including mid). Time: O(log n), Space: O(1).",
    "optimalCode": "def findMin(nums: list[int]) -> int:\n    left, right = 0, len(nums) - 1\n    while left < right:\n        mid = (left + right) // 2\n        if nums[mid] > nums[right]:\n            left = mid + 1\n        else:\n            right = mid\n    return nums[left]"
  },
  {
    "id": "longest-increasing-subsequence",
    "title": "Longest Increasing Subsequence",
    "difficulty": "Medium",
    "description": "Given an integer array `nums`, return the length of the longest strictly increasing subsequence.",
    "examples": [
      {
        "input": "nums = [10,9,2,5,3,7,101,18]",
        "output": "4",
        "explanation": "The longest increasing subsequence is [2,3,7,101], length 4."
      },
      {
        "input": "nums = [0,1,0,3,2,3]",
        "output": "4",
        "explanation": null
      },
      {
        "input": "nums = [7,7,7,7,7,7,7]",
        "output": "1",
        "explanation": null
      }
    ],
    "functionSignature": "def lengthOfLIS(nums: list[int]) -> int:",
    "starterCode": "def lengthOfLIS(nums: list[int]) -> int:\n    # Write your solution here\n    pass",
    "tags": [
      "Arrays",
      "Dynamic Programming",
      "Binary Search"
    ],
    "hints": [
      "Think about dynamic programming: for each element, compute the longest increasing subsequence ending at that element.",
      "The basic DP approach: dp[i] = max(dp[j] + 1) for all j < i where nums[j] < nums[i]. This is O(n^2).",
      "For O(n log n), maintain a tails array where tails[i] is the smallest tail element for an increasing subsequence of length i+1. Use binary search to find the insertion point for each new element."
    ],
    "solutionExplanation": "Use dynamic programming with binary search (patience sorting). Maintain a tails array and use bisect to find insertion positions. Time: O(n log n), Space: O(n).",
    "optimalCode": "def lengthOfLIS(nums: list[int]) -> int:\n    from bisect import bisect_left\n    tails = []\n    for num in nums:\n        pos = bisect_left(tails, num)\n        if pos == len(tails):\n            tails.append(num)\n        else:\n            tails[pos] = num\n    return len(tails)"
  },
  {
    "id": "word-break",
    "title": "Word Break",
    "difficulty": "Medium",
    "description": "Given a string `s` and a dictionary of strings `wordDict`, return `true` if `s` can be segmented into a space-separated sequence of one or more dictionary words.",
    "examples": [
      {
        "input": "s = \"leetcode\", wordDict = [\"leet\",\"code\"]",
        "output": "true",
        "explanation": "Return true because \"leetcode\" can be segmented as \"leet code\"."
      },
      {
        "input": "s = \"applepenapple\", wordDict = [\"apple\",\"pen\"]",
        "output": "true",
        "explanation": "Return true because \"applepenapple\" can be segmented as \"apple pen apple\"."
      },
      {
        "input": "s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]",
        "output": "false",
        "explanation": null
      }
    ],
    "functionSignature": "def wordBreak(s: str, wordDict: list[str]) -> bool:",
    "starterCode": "def wordBreak(s: str, wordDict: list[str]) -> bool:\n    # Write your solution here\n    pass",
    "tags": [
      "Strings",
      "Dynamic Programming"
    ],
    "hints": [
      "Think about dynamic programming where dp[i] represents whether the substring s[0:i] can be segmented.",
      "For each position i, check all possible last words: is there a j < i such that dp[j] is true and s[j:i] is in the dictionary?",
      "Convert the word dictionary to a set for O(1) lookups. To optimize, limit the inner loop to the maximum word length in the dictionary."
    ],
    "solutionExplanation": "Use bottom-up DP where dp[i] is true if s[0:i] can be segmented. For each position, check all possible last words from the dictionary. Time: O(n² * m), Space: O(n).",
    "optimalCode": "def wordBreak(s: str, wordDict: list[str]) -> bool:\n    word_set = set(wordDict)\n    dp = [False] * (len(s) + 1)\n    dp[0] = True\n    for i in range(1, len(s) + 1):\n        for j in range(i):\n            if dp[j] and s[j:i] in word_set:\n                dp[i] = True\n                break\n    return dp[len(s)]"
  },
  {
    "id": "decode-ways",
    "title": "Decode Ways",
    "difficulty": "Medium",
    "description": "A message containing letters A-Z can be encoded by mapping 'A' -> \"1\", 'B' -> \"2\", ..., 'Z' -> \"26\".\n\nGiven a string `s` containing only digits, return the number of ways to decode it. The answer is guaranteed to fit in a 32-bit integer.",
    "examples": [
      {
        "input": "s = \"12\"",
        "output": "2",
        "explanation": "\"12\" could be decoded as \"AB\" (1 2) or \"L\" (12)."
      },
      {
        "input": "s = \"226\"",
        "output": "3",
        "explanation": "\"226\" could be decoded as \"BZ\" (2 26), \"VF\" (22 6), or \"BBF\" (2 2 6)."
      },
      {
        "input": "s = \"06\"",
        "output": "0",
        "explanation": "\"06\" cannot be mapped because 0 is not a valid encoding."
      }
    ],
    "functionSignature": "def numDecodings(s: str) -> int:",
    "starterCode": "def numDecodings(s: str) -> int:\n    # Write your solution here\n    pass",
    "tags": [
      "Strings",
      "Dynamic Programming"
    ],
    "hints": [
      "This is similar to climbing stairs but with validity constraints. Think about dp[i] as the number of ways to decode the first i characters.",
      "At each position, you can decode one digit (if it's 1-9) and optionally two digits (if they form 10-26). dp[i] = dp[i-1] (if valid single) + dp[i-2] (if valid double).",
      "The key edge case is '0': it cannot be decoded alone, so it must be part of '10' or '20'. If a '0' doesn't follow '1' or '2', the string is invalid (return 0)."
    ],
    "solutionExplanation": "Dynamic programming similar to climbing stairs. dp[i] depends on whether the last one or two digits form valid codes (1-26). Time: O(n), Space: O(1).",
    "optimalCode": "def numDecodings(s: str) -> int:\n    if not s or s[0] == '0':\n        return 0\n    n = len(s)\n    prev2, prev1 = 1, 1\n    for i in range(1, n):\n        current = 0\n        if s[i] != '0':\n            current = prev1\n        two_digit = int(s[i-1:i+1])\n        if 10 <= two_digit <= 26:\n            current += prev2\n        prev2 = prev1\n        prev1 = current\n    return prev1"
  },
  {
    "id": "kth-largest-element",
    "title": "Kth Largest Element in an Array",
    "difficulty": "Medium",
    "description": "Given an integer array `nums` and an integer `k`, return the kth largest element in the array.\n\nNote that it is the kth largest element in the sorted order, not the kth distinct element.",
    "examples": [
      {
        "input": "nums = [3,2,1,5,6,4], k = 2",
        "output": "5",
        "explanation": null
      },
      {
        "input": "nums = [3,2,3,1,2,4,5,5,6], k = 4",
        "output": "4",
        "explanation": null
      }
    ],
    "functionSignature": "def findKthLargest(nums: list[int], k: int) -> int:",
    "starterCode": "def findKthLargest(nums: list[int], k: int) -> int:\n    # Write your solution here\n    pass",
    "tags": [
      "Arrays",
      "Sorting"
    ],
    "hints": [
      "Think about using a heap (priority queue) to efficiently find the kth largest element.",
      "Maintain a min-heap of size k. After processing all elements, the top of the heap is the kth largest.",
      "For each element, add it to the heap. If the heap size exceeds k, remove the smallest. This way, the heap always contains the k largest elements seen so far."
    ],
    "solutionExplanation": "Use a min-heap of size k. After processing all elements, the heap top is the kth largest. Alternatively, use quickselect for average O(n). Time: O(n log k) with heap, Space: O(k).",
    "optimalCode": "def findKthLargest(nums: list[int], k: int) -> int:\n    import heapq\n    return heapq.nlargest(k, nums)[-1]"
  },
  {
    "id": "first-missing-positive",
    "title": "First Missing Positive",
    "difficulty": "Hard",
    "description": "Given an unsorted integer array `nums`, return the smallest missing positive integer.\n\nYou must implement an algorithm that runs in O(n) time and uses O(1) auxiliary space.",
    "examples": [
      {
        "input": "nums = [1,2,0]",
        "output": "3",
        "explanation": "Numbers 1 and 2 are present, so 3 is the smallest missing positive."
      },
      {
        "input": "nums = [3,4,-1,1]",
        "output": "2",
        "explanation": "1 is present but 2 is missing."
      },
      {
        "input": "nums = [7,8,9,11,12]",
        "output": "1",
        "explanation": "1 is the smallest positive integer."
      }
    ],
    "functionSignature": "def firstMissingPositive(nums: list[int]) -> int:",
    "starterCode": "def firstMissingPositive(nums: list[int]) -> int:\n    # Write your solution here\n    pass",
    "tags": [
      "Arrays",
      "Hash Map"
    ],
    "hints": [
      "The answer must be in the range [1, n+1] where n is the array length. Think about using the array indices themselves as a hash table.",
      "Use cyclic sort: place each positive number i at index i-1. Swap nums[i] with nums[nums[i]-1] until each position holds the correct value or an out-of-range value.",
      "After sorting, scan the array. The first index i where nums[i] != i + 1 gives the answer i + 1. If all positions are correct, the answer is n + 1."
    ],
    "solutionExplanation": "Place each number in its correct index position (cyclic sort). Then scan for the first position where index + 1 != value. Time: O(n), Space: O(1).",
    "optimalCode": "def firstMissingPositive(nums: list[int]) -> int:\n    n = len(nums)\n    for i in range(n):\n        while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:\n            nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]\n    for i in range(n):\n        if nums[i] != i + 1:\n            return i + 1\n    return n + 1"
  },
  {
    "id": "minimum-window-substring",
    "title": "Minimum Window Substring",
    "difficulty": "Hard",
    "description": "Given two strings `s` and `t` of lengths `m` and `n` respectively, return the minimum window substring of `s` such that every character in `t` (including duplicates) is included in the window.\n\nIf there is no such substring, return the empty string \"\".",
    "examples": [
      {
        "input": "s = \"ADOBECODEBANC\", t = \"ABC\"",
        "output": "\"BANC\"",
        "explanation": "The minimum window substring \"BANC\" includes 'A', 'B', and 'C' from string t."
      },
      {
        "input": "s = \"a\", t = \"a\"",
        "output": "\"a\"",
        "explanation": null
      },
      {
        "input": "s = \"a\", t = \"aa\"",
        "output": "\"\"",
        "explanation": "Both 'a's from t must be included. Since s only has one 'a', return empty string."
      }
    ],
    "functionSignature": "def minWindow(s: str, t: str) -> str:",
    "starterCode": "def minWindow(s: str, t: str) -> str:\n    # Write your solution here\n    pass",
    "tags": [
      "Strings",
      "Sliding Window",
      "Hash Map"
    ],
    "hints": [
      "Use a sliding window with two pointers and a frequency map of characters needed from t.",
      "Expand the window by moving the right pointer until all characters in t are covered. Then shrink from the left to find the minimum valid window.",
      "Use a 'formed' counter to track how many unique characters in t have their required frequency met. This avoids rechecking the entire frequency map each time."
    ],
    "solutionExplanation": "Use a sliding window with two pointers and a character frequency map. Expand right to include all chars, then shrink left to minimize the window. Time: O(n + m), Space: O(m).",
    "optimalCode": "def minWindow(s: str, t: str) -> str:\n    from collections import Counter\n    need = Counter(t)\n    missing = len(t)\n    left = 0\n    start, end = 0, float('inf')\n    for right in range(len(s)):\n        if need[s[right]] > 0:\n            missing -= 1\n        need[s[right]] -= 1\n        while missing == 0:\n            if right - left < end - start:\n                start, end = left, right\n            need[s[left]] += 1\n            if need[s[left]] > 0:\n                missing += 1\n            left += 1\n    return '' if end == float('inf') else s[start:end + 1]"
  },
  {
    "id": "edit-distance",
    "title": "Edit Distance",
    "difficulty": "Hard",
    "description": "Given two strings `word1` and `word2`, return the minimum number of operations required to convert `word1` to `word2`.\n\nYou have three operations: Insert a character, Delete a character, Replace a character.",
    "examples": [
      {
        "input": "word1 = \"horse\", word2 = \"ros\"",
        "output": "3",
        "explanation": "horse -> rorse (replace 'h' with 'r') -> rose (remove 'r') -> ros (remove 'e')"
      },
      {
        "input": "word1 = \"intention\", word2 = \"execution\"",
        "output": "5",
        "explanation": null
      }
    ],
    "functionSignature": "def minDistance(word1: str, word2: str) -> int:",
    "starterCode": "def minDistance(word1: str, word2: str) -> int:\n    # Write your solution here\n    pass",
    "tags": [
      "Strings",
      "Dynamic Programming"
    ],
    "hints": [
      "Think about a 2D dynamic programming table where dp[i][j] is the edit distance between word1[0:i] and word2[0:j].",
      "If characters match (word1[i-1] == word2[j-1]), dp[i][j] = dp[i-1][j-1]. Otherwise, take the minimum of insert (dp[i][j-1]+1), delete (dp[i-1][j]+1), and replace (dp[i-1][j-1]+1).",
      "Initialize the first row and column with values 0 to n and 0 to m respectively, representing the cost of converting to/from an empty string."
    ],
    "solutionExplanation": "Use 2D dynamic programming where dp[i][j] represents min edits for word1[0:i] to word2[0:j]. Each cell considers insert, delete, or replace. Time: O(m*n), Space: O(m*n).",
    "optimalCode": "def minDistance(word1: str, word2: str) -> int:\n    m, n = len(word1), len(word2)\n    dp = list(range(n + 1))\n    for i in range(1, m + 1):\n        prev = dp[0]\n        dp[0] = i\n        for j in range(1, n + 1):\n            temp = dp[j]\n            if word1[i-1] == word2[j-1]:\n                dp[j] = prev\n            else:\n                dp[j] = 1 + min(prev, dp[j], dp[j-1])\n            prev = temp\n    return dp[n]"
  },
  {
    "id": "largest-rectangle-histogram",
    "title": "Largest Rectangle in Histogram",
    "difficulty": "Hard",
    "description": "Given an array of integers `heights` representing the histogram's bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram.",
    "examples": [
      {
        "input": "heights = [2,1,5,6,2,3]",
        "output": "10",
        "explanation": "The largest rectangle has an area of 10 (bars at index 2 and 3 with height 5)."
      },
      {
        "input": "heights = [2,4]",
        "output": "4",
        "explanation": null
      }
    ],
    "functionSignature": "def largestRectangleArea(heights: list[int]) -> int:",
    "starterCode": "def largestRectangleArea(heights: list[int]) -> int:\n    # Write your solution here\n    pass",
    "tags": [
      "Stack",
      "Arrays"
    ],
    "hints": [
      "Think about using a stack to efficiently find the nearest smaller bar on each side of every bar.",
      "Use a monotonic increasing stack storing indices. When a bar is shorter than the stack top, pop and calculate the area using the popped bar as the shortest in the rectangle.",
      "The width of the rectangle is determined by the current index and the new stack top after popping. Add a sentinel (height 0) at the end to flush all remaining bars from the stack."
    ],
    "solutionExplanation": "Use a monotonic stack to find the nearest smaller bar on each side. The rectangle for each bar extends between its left and right boundaries. Time: O(n), Space: O(n).",
    "optimalCode": "def largestRectangleArea(heights: list[int]) -> int:\n    stack = []\n    max_area = 0\n    heights.append(0)\n    for i in range(len(heights)):\n        while stack and heights[i] < heights[stack[-1]]:\n            h = heights[stack.pop()]\n            w = i if not stack else i - stack[-1] - 1\n            max_area = max(max_area, h * w)\n        stack.append(i)\n    heights.pop()\n    return max_area"
  },
  {
    "id": "reverse-linked-list",
    "title": "Reverse Linked List",
    "difficulty": "Easy",
    "description": "Given an array representing a linked list, return the reversed array.",
    "examples": [
      {
        "input": "head = [1,2,3,4,5]",
        "output": "[5,4,3,2,1]",
        "explanation": null
      },
      {
        "input": "head = [1,2]",
        "output": "[2,1]",
        "explanation": null
      }
    ],
    "functionSignature": "def reverseList(head: list[int]) -> list[int]:",
    "starterCode": "def reverseList(head: list[int]) -> list[int]:\n    # Write your solution here\n    pass",
    "tags": [
      "Arrays"
    ],
    "hints": [
      "Try using Python slicing.",
      "Two pointers can also work: swap from both ends."
    ],
    "solutionExplanation": "Reverse using slicing or two pointers. Time: O(n), Space: O(1) with two pointers.",
    "optimalCode": "def reverseList(head: list[int]) -> list[int]:\n    return head[::-1]"
  },
  {
    "id": "max-depth-binary-tree",
    "title": "Maximum Depth of Binary Tree",
    "difficulty": "Easy",
    "description": "Given a binary tree represented as a level-order array (None for missing nodes), return its maximum depth. The depth is the number of nodes along the longest path from root to the farthest leaf.",
    "examples": [
      {
        "input": "root = [3,9,20,None,None,15,7]",
        "output": "3",
        "explanation": null
      },
      {
        "input": "root = [1,None,2]",
        "output": "2",
        "explanation": null
      },
      {
        "input": "root = []",
        "output": "0",
        "explanation": null
      }
    ],
    "functionSignature": "def maxDepth(root: list) -> int:",
    "starterCode": "def maxDepth(root: list) -> int:\n    # Write your solution here\n    pass",
    "tags": [
      "Tree",
      "DFS",
      "Recursion"
    ],
    "hints": [
      "Build the tree recursively or use BFS level by level.",
      "For BFS, each level you process adds 1 to the depth."
    ],
    "solutionExplanation": "Use BFS to count levels. Process nodes level by level, incrementing depth each time. Time: O(n), Space: O(n).",
    "optimalCode": "def maxDepth(root: list) -> int:\n    if not root or root[0] is None:\n        return 0\n    from collections import deque\n    queue = deque([0])\n    depth = 0\n    while queue:\n        depth += 1\n        for _ in range(len(queue)):\n            i = queue.popleft()\n            left = 2 * i + 1\n            right = 2 * i + 2\n            if left < len(root) and root[left] is not None:\n                queue.append(left)\n            if right < len(root) and root[right] is not None:\n                queue.append(right)\n    return depth"
  },
  {
    "id": "invert-binary-tree",
    "title": "Invert Binary Tree",
    "difficulty": "Easy",
    "description": "Given a binary tree as a level-order array, invert it (mirror it) and return the result as a level-order array.",
    "examples": [
      {
        "input": "root = [4,2,7,1,3,6,9]",
        "output": "[4,7,2,9,6,3,1]",
        "explanation": null
      },
      {
        "input": "root = [2,1,3]",
        "output": "[2,3,1]",
        "explanation": null
      },
      {
        "input": "root = []",
        "output": "[]",
        "explanation": null
      }
    ],
    "functionSignature": "def invertTree(root: list) -> list:",
    "starterCode": "def invertTree(root: list) -> list:\n    # Write your solution here\n    pass",
    "tags": [
      "Tree",
      "DFS",
      "Recursion"
    ],
    "hints": [
      "Swap left and right children at each level.",
      "For a level-order array, think about the positions of left and right children."
    ],
    "solutionExplanation": "Build actual tree nodes, recursively swap children, then serialize back to level-order. Or work directly on the array by swapping children at each level. Time: O(n), Space: O(n).",
    "optimalCode": "def invertTree(root: list) -> list:\n    if not root:\n        return []\n    from collections import deque\n    n = len(root)\n    result = list(root)\n    queue = deque([0])\n    while queue:\n        i = queue.popleft()\n        left = 2 * i + 1\n        right = 2 * i + 2\n        if left < n and right < n:\n            result[left], result[right] = result[right], result[left]\n        if left < n and result[left] is not None:\n            queue.append(left)\n        if right < n and result[right] is not None:\n            queue.append(right)\n    return result"
  },
  {
    "id": "symmetric-tree",
    "title": "Symmetric Tree",
    "difficulty": "Easy",
    "description": "Given a binary tree as a level-order array, check whether it is a mirror of itself (symmetric around its center).",
    "examples": [
      {
        "input": "root = [1,2,2,3,4,4,3]",
        "output": "true",
        "explanation": null
      },
      {
        "input": "root = [1,2,2,None,3,None,3]",
        "output": "false",
        "explanation": null
      }
    ],
    "functionSignature": "def isSymmetric(root: list) -> bool:",
    "starterCode": "def isSymmetric(root: list) -> bool:\n    # Write your solution here\n    pass",
    "tags": [
      "Tree",
      "DFS",
      "BFS"
    ],
    "hints": [
      "Compare the tree level by level.",
      "At each level, check if the values form a palindrome."
    ],
    "solutionExplanation": "Check each level of the tree for palindrome symmetry. Time: O(n), Space: O(n).",
    "optimalCode": "def isSymmetric(root: list) -> bool:\n    if not root:\n        return True\n    from collections import deque\n    queue = deque([0])\n    while queue:\n        level_vals = []\n        for _ in range(len(queue)):\n            i = queue.popleft()\n            left = 2 * i + 1\n            right = 2 * i + 2\n            level_vals.append(root[left] if left < len(root) else None)\n            level_vals.append(root[right] if right < len(root) else None)\n            if left < len(root) and root[left] is not None:\n                queue.append(left)\n            if right < len(root) and root[right] is not None:\n                queue.append(right)\n        if level_vals != level_vals[::-1]:\n            return False\n    return True"
  },
  {
    "id": "number-of-1-bits",
    "title": "Number of 1 Bits",
    "difficulty": "Easy",
    "description": "Given a positive integer n, return the number of set bits (1s) in its binary representation (also known as the Hamming weight).",
    "examples": [
      {
        "input": "n = 11",
        "output": "3",
        "explanation": "Binary representation is 1011, which has three 1 bits."
      },
      {
        "input": "n = 128",
        "output": "1",
        "explanation": "Binary representation is 10000000, which has one 1 bit."
      },
      {
        "input": "n = 255",
        "output": "8",
        "explanation": null
      }
    ],
    "functionSignature": "def hammingWeight(n: int) -> int:",
    "starterCode": "def hammingWeight(n: int) -> int:\n    # Write your solution here\n    pass",
    "tags": [
      "Bit Manipulation"
    ],
    "hints": [
      "Use bin() to get binary representation and count '1's.",
      "Or use bit manipulation: n & (n-1) clears the lowest set bit."
    ],
    "solutionExplanation": "Count set bits using bin().count('1') or the n & (n-1) trick. Time: O(log n), Space: O(1).",
    "optimalCode": "def hammingWeight(n: int) -> int:\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count"
  },
  {
    "id": "implement-queue-stacks",
    "title": "Implement Queue using Stacks",
    "difficulty": "Easy",
    "description": "Implement a first-in-first-out (FIFO) queue using only two stacks. The queue should support push (add to back), pop (remove from front), peek (get front element), and empty (check if empty). Given a list of operations and arguments, return the results.",
    "examples": [
      {
        "input": "operations = [\"push\",\"push\",\"peek\",\"pop\",\"empty\"], arguments = [[1],[2],[],[],[]]",
        "output": "[None,None,1,1,false]",
        "explanation": null
      }
    ],
    "functionSignature": "def queueUsingStacks(operations: list[str], arguments: list[list]) -> list:",
    "starterCode": "def queueUsingStacks(operations: list[str], arguments: list[list]) -> list:\n    # Write your solution here\n    pass",
    "tags": [
      "Queue",
      "Stack",
      "Design"
    ],
    "hints": [
      "Use two stacks: one for push, one for pop.",
      "Only transfer elements between stacks when the pop stack is empty."
    ],
    "solutionExplanation": "Use two stacks. Push to stack1. For pop/peek, if stack2 is empty, transfer all from stack1. Time: O(1) amortized per operation.",
    "optimalCode": "def queueUsingStacks(operations: list[str], arguments: list[list]) -> list:\n    stack1, stack2 = [], []\n    results = []\n    for op, args in zip(operations, arguments):\n        if op == \"push\":\n            stack1.append(args[0])\n            results.append(None)\n        elif op == \"pop\":\n            if not stack2:\n                while stack1:\n                    stack2.append(stack1.pop())\n            results.append(stack2.pop())\n        elif op == \"peek\":\n            if not stack2:\n                while stack1:\n                    stack2.append(stack1.pop())\n            results.append(stack2[-1])\n        elif op == \"empty\":\n            results.append(len(stack1) == 0 and len(stack2) == 0)\n    return results"
  },
  {
    "id": "find-duplicate-number",
    "title": "Find the Duplicate Number",
    "difficulty": "Medium",
    "description": "Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), there is exactly one repeated number. Find and return this duplicate number. You must not modify the array and use only constant extra space.",
    "examples": [
      {
        "input": "nums = [1,3,4,2,2]",
        "output": "2",
        "explanation": null
      },
      {
        "input": "nums = [3,1,3,4,2]",
        "output": "3",
        "explanation": null
      },
      {
        "input": "nums = [1,1]",
        "output": "1",
        "explanation": null
      }
    ],
    "functionSignature": "def findDuplicate(nums: list[int]) -> int:",
    "starterCode": "def findDuplicate(nums: list[int]) -> int:\n    # Write your solution here\n    pass",
    "tags": [
      "Arrays",
      "Two Pointers"
    ],
    "hints": [
      "Think of the array values as pointers to indices (like a linked list).",
      "Use Floyd's cycle detection (tortoise and hare) to find the duplicate."
    ],
    "solutionExplanation": "Use Floyd's cycle detection: slow moves one step, fast moves two steps. When they meet, reset one to start and advance both by one until they meet again. Time: O(n), Space: O(1).",
    "optimalCode": "def findDuplicate(nums: list[int]) -> int:\n    slow = fast = nums[0]\n    while True:\n        slow = nums[slow]\n        fast = nums[nums[fast]]\n        if slow == fast:\n            break\n    slow = nums[0]\n    while slow != fast:\n        slow = nums[slow]\n        fast = nums[fast]\n    return slow"
  },
  {
    "id": "binary-tree-level-order",
    "title": "Binary Tree Level Order Traversal",
    "difficulty": "Medium",
    "description": "Given a binary tree as a level-order array (None for missing nodes), return the level order traversal of its node values as a list of lists (each list contains the values at that level).",
    "examples": [
      {
        "input": "root = [3,9,20,None,None,15,7]",
        "output": "[[3],[9,20],[15,7]]",
        "explanation": null
      },
      {
        "input": "root = [1]",
        "output": "[[1]]",
        "explanation": null
      },
      {
        "input": "root = []",
        "output": "[]",
        "explanation": null
      }
    ],
    "functionSignature": "def levelOrder(root: list) -> list[list[int]]:",
    "starterCode": "def levelOrder(root: list) -> list[list[int]]:\n    # Write your solution here\n    pass",
    "tags": [
      "Tree",
      "BFS"
    ],
    "hints": [
      "Use BFS with a queue.",
      "Process all nodes at the current level before moving to the next."
    ],
    "solutionExplanation": "Use BFS. Process nodes level by level, collecting values at each level into a sublist. Time: O(n), Space: O(n).",
    "optimalCode": "def levelOrder(root: list) -> list[list[int]]:\n    if not root or root[0] is None:\n        return []\n    from collections import deque\n    result = []\n    queue = deque([0])\n    while queue:\n        level = []\n        for _ in range(len(queue)):\n            i = queue.popleft()\n            level.append(root[i])\n            left = 2 * i + 1\n            right = 2 * i + 2\n            if left < len(root) and root[left] is not None:\n                queue.append(left)\n            if right < len(root) and root[right] is not None:\n                queue.append(right)\n        result.append(level)\n    return result"
  },
  {
    "id": "validate-bst",
    "title": "Validate Binary Search Tree",
    "difficulty": "Medium",
    "description": "Given a binary tree as a level-order array, determine if it is a valid binary search tree (BST). A valid BST has: left subtree values less than node, right subtree values greater than node.",
    "examples": [
      {
        "input": "root = [2,1,3]",
        "output": "true",
        "explanation": null
      },
      {
        "input": "root = [5,1,4,None,None,3,6]",
        "output": "false",
        "explanation": null
      }
    ],
    "functionSignature": "def isValidBST(root: list) -> bool:",
    "starterCode": "def isValidBST(root: list) -> bool:\n    # Write your solution here\n    pass",
    "tags": [
      "Tree",
      "DFS"
    ],
    "hints": [
      "Use DFS with min/max bounds for each node.",
      "The in-order traversal of a valid BST produces sorted values."
    ],
    "solutionExplanation": "DFS with bounds: each node must be within (min, max). Left child narrows max, right child narrows min. Time: O(n), Space: O(n).",
    "optimalCode": "def isValidBST(root: list) -> bool:\n    if not root:\n        return True\n    def validate(i, low, high):\n        if i >= len(root) or root[i] is None:\n            return True\n        if root[i] <= low or root[i] >= high:\n            return False\n        return validate(2*i+1, low, root[i]) and validate(2*i+2, root[i], high)\n    return validate(0, float('-inf'), float('inf'))"
  },
  {
    "id": "course-schedule",
    "title": "Course Schedule",
    "difficulty": "Medium",
    "description": "There are numCourses courses labeled from 0 to numCourses-1. You are given an array of prerequisites where prerequisites[i] = [ai, bi] indicates you must take course bi first to take course ai. Return true if you can finish all courses.",
    "examples": [
      {
        "input": "numCourses = 2, prerequisites = [[1,0]]",
        "output": "true",
        "explanation": null
      },
      {
        "input": "numCourses = 2, prerequisites = [[1,0],[0,1]]",
        "output": "false",
        "explanation": null
      }
    ],
    "functionSignature": "def canFinish(numCourses: int, prerequisites: list[list[int]]) -> bool:",
    "starterCode": "def canFinish(numCourses: int, prerequisites: list[list[int]]) -> bool:\n    # Write your solution here\n    pass",
    "tags": [
      "Graph",
      "BFS",
      "DFS"
    ],
    "hints": [
      "Model this as a directed graph. If there's a cycle, you can't finish all courses.",
      "Use topological sort (BFS with in-degree counting) or DFS cycle detection."
    ],
    "solutionExplanation": "Use topological sort with BFS: count in-degrees, start from nodes with 0 in-degree. If all nodes are processed, no cycle exists. Time: O(V+E), Space: O(V+E).",
    "optimalCode": "def canFinish(numCourses: int, prerequisites: list[list[int]]) -> bool:\n    from collections import deque, defaultdict\n    graph = defaultdict(list)\n    in_degree = [0] * numCourses\n    for a, b in prerequisites:\n        graph[b].append(a)\n        in_degree[a] += 1\n    queue = deque(i for i in range(numCourses) if in_degree[i] == 0)\n    count = 0\n    while queue:\n        node = queue.popleft()\n        count += 1\n        for neighbor in graph[node]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    return count == numCourses"
  },
  {
    "id": "number-of-islands",
    "title": "Number of Islands",
    "difficulty": "Medium",
    "description": "Given an m x n 2D grid of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically.",
    "examples": [
      {
        "input": "grid = [[\"1\",\"1\",\"1\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"0\",\"0\"]]",
        "output": "1",
        "explanation": null
      },
      {
        "input": "grid = [[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"1\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"1\",\"1\"]]",
        "output": "3",
        "explanation": null
      }
    ],
    "functionSignature": "def numIslands(grid: list[list[str]]) -> int:",
    "starterCode": "def numIslands(grid: list[list[str]]) -> int:\n    # Write your solution here\n    pass",
    "tags": [
      "Graph",
      "DFS",
      "Matrix"
    ],
    "hints": [
      "Use DFS or BFS. When you find a '1', mark all connected '1's as visited.",
      "Count how many times you initiate a new DFS/BFS."
    ],
    "solutionExplanation": "Iterate through grid. When finding '1', DFS to mark all connected land as visited, increment count. Time: O(m*n), Space: O(m*n).",
    "optimalCode": "def numIslands(grid: list[list[str]]) -> int:\n    if not grid:\n        return 0\n    rows, cols = len(grid), len(grid[0])\n    count = 0\n    def dfs(r, c):\n        if r < 0 or r >= rows or c < 0 or c >= cols or grid[r][c] != '1':\n            return\n        grid[r][c] = '0'\n        dfs(r+1, c)\n        dfs(r-1, c)\n        dfs(r, c+1)\n        dfs(r, c-1)\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] == '1':\n                count += 1\n                dfs(r, c)\n    return count"
  },
  {
    "id": "kth-smallest-bst",
    "title": "Kth Smallest Element in a BST",
    "difficulty": "Medium",
    "description": "Given the root of a binary search tree as a level-order array and an integer k, return the kth smallest value (1-indexed) in the tree.",
    "examples": [
      {
        "input": "root = [3,1,4,None,2], k = 1",
        "output": "1",
        "explanation": null
      },
      {
        "input": "root = [5,3,6,2,4,None,None,1], k = 3",
        "output": "3",
        "explanation": null
      }
    ],
    "functionSignature": "def kthSmallest(root: list, k: int) -> int:",
    "starterCode": "def kthSmallest(root: list, k: int) -> int:\n    # Write your solution here\n    pass",
    "tags": [
      "Tree",
      "DFS"
    ],
    "hints": [
      "In-order traversal of a BST gives sorted values.",
      "You don't need to complete the full traversal — stop at the kth element."
    ],
    "solutionExplanation": "Perform in-order traversal (left, root, right) and return the kth element. Time: O(n), Space: O(n).",
    "optimalCode": "def kthSmallest(root: list, k: int) -> int:\n    def inorder(i):\n        if i >= len(root) or root[i] is None:\n            return []\n        return inorder(2*i+1) + [root[i]] + inorder(2*i+2)\n    return inorder(0)[k-1]"
  },
  {
    "id": "lru-cache",
    "title": "LRU Cache",
    "difficulty": "Medium",
    "description": "Design and implement a Least Recently Used (LRU) cache. Given a capacity, list of operations ('put' or 'get'), and their arguments, return the results. 'get' returns the value or -1 if not found. 'put' adds or updates the key-value pair, evicting the least recently used item if at capacity.",
    "examples": [
      {
        "input": "capacity = 2, operations = [\"put\",\"put\",\"get\",\"put\",\"get\",\"put\",\"get\",\"get\",\"get\"], arguments = [[1,1],[2,2],[1],[3,3],[2],[4,4],[1],[3],[4]]",
        "output": "[None,None,1,None,-1,None,-1,3,4]",
        "explanation": null
      }
    ],
    "functionSignature": "def lruCache(capacity: int, operations: list[str], arguments: list[list[int]]) -> list:",
    "starterCode": "def lruCache(capacity: int, operations: list[str], arguments: list[list[int]]) -> list:\n    # Write your solution here\n    pass",
    "tags": [
      "Design",
      "Hash Map"
    ],
    "hints": [
      "Use an OrderedDict to maintain insertion/access order.",
      "Move items to the end on access, pop from the front on eviction."
    ],
    "solutionExplanation": "Use collections.OrderedDict. On get, move to end. On put, if key exists update and move to end; if full, pop first item. Time: O(1) per operation.",
    "optimalCode": "def lruCache(capacity: int, operations: list[str], arguments: list[list[int]]) -> list:\n    from collections import OrderedDict\n    cache = OrderedDict()\n    results = []\n    for op, args in zip(operations, arguments):\n        if op == \"get\":\n            key = args[0]\n            if key in cache:\n                cache.move_to_end(key)\n                results.append(cache[key])\n            else:\n                results.append(-1)\n        elif op == \"put\":\n            key, value = args[0], args[1]\n            if key in cache:\n                cache.move_to_end(key)\n            cache[key] = value\n            if len(cache) > capacity:\n                cache.popitem(last=False)\n            results.append(None)\n    return results"
  },
  {
    "id": "task-scheduler",
    "title": "Task Scheduler",
    "difficulty": "Medium",
    "description": "Given a list of CPU tasks represented by characters and a cooling interval n, return the minimum number of intervals the CPU will take to finish all tasks. The same task must wait at least n intervals before executing again.",
    "examples": [
      {
        "input": "tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 2",
        "output": "8",
        "explanation": null
      },
      {
        "input": "tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 0",
        "output": "6",
        "explanation": null
      },
      {
        "input": "tasks = [\"A\",\"A\",\"A\",\"A\",\"A\",\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\"], n = 2",
        "output": "16",
        "explanation": null
      }
    ],
    "functionSignature": "def leastInterval(tasks: list[str], n: int) -> int:",
    "starterCode": "def leastInterval(tasks: list[str], n: int) -> int:\n    # Write your solution here\n    pass",
    "tags": [
      "Greedy",
      "Heap"
    ],
    "hints": [
      "The most frequent task determines the minimum length.",
      "Calculate: (max_count - 1) * (n + 1) + number_of_tasks_with_max_count."
    ],
    "solutionExplanation": "Count task frequencies. The most frequent task creates (max_freq - 1) groups of size (n+1), plus the tasks tied for max frequency. Answer is max of this formula and total tasks. Time: O(n), Space: O(1).",
    "optimalCode": "def leastInterval(tasks: list[str], n: int) -> int:\n    from collections import Counter\n    counts = Counter(tasks)\n    max_count = max(counts.values())\n    max_count_tasks = sum(1 for v in counts.values() if v == max_count)\n    return max(len(tasks), (max_count - 1) * (n + 1) + max_count_tasks)"
  },
  {
    "id": "word-ladder",
    "title": "Word Ladder",
    "difficulty": "Hard",
    "description": "Given two words beginWord and endWord, and a word list, return the number of words in the shortest transformation sequence from beginWord to endWord. Each transformation changes exactly one letter. Every transformed word must exist in the word list. Return 0 if no transformation sequence exists.",
    "examples": [
      {
        "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]",
        "output": "5",
        "explanation": null
      },
      {
        "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]",
        "output": "0",
        "explanation": null
      }
    ],
    "functionSignature": "def ladderLength(beginWord: str, endWord: str, wordList: list[str]) -> int:",
    "starterCode": "def ladderLength(beginWord: str, endWord: str, wordList: list[str]) -> int:\n    # Write your solution here\n    pass",
    "tags": [
      "Graph",
      "BFS"
    ],
    "hints": [
      "Use BFS. Each word is a node, edges connect words that differ by one letter.",
      "Use wildcard patterns (e.g., h*t) to find neighbors efficiently."
    ],
    "solutionExplanation": "BFS from beginWord. For each word, try changing each character to find neighbors in wordList. Track visited words. Time: O(M^2 * N) where M is word length, N is wordList size.",
    "optimalCode": "def ladderLength(beginWord: str, endWord: str, wordList: list[str]) -> int:\n    from collections import deque\n    word_set = set(wordList)\n    if endWord not in word_set:\n        return 0\n    queue = deque([(beginWord, 1)])\n    visited = {beginWord}\n    while queue:\n        word, length = queue.popleft()\n        for i in range(len(word)):\n            for c in 'abcdefghijklmnopqrstuvwxyz':\n                next_word = word[:i] + c + word[i+1:]\n                if next_word == endWord:\n                    return length + 1\n                if next_word in word_set and next_word not in visited:\n                    visited.add(next_word)\n                    queue.append((next_word, length + 1))\n    return 0"
  },
  {
    "id": "merge-k-sorted-lists",
    "title": "Merge k Sorted Lists",
    "difficulty": "Hard",
    "description": "You are given an array of k sorted arrays. Merge all arrays into one sorted array and return it.",
    "examples": [
      {
        "input": "lists = [[1,4,5],[1,3,4],[2,6]]",
        "output": "[1,1,2,3,4,4,5,6]",
        "explanation": null
      },
      {
        "input": "lists = []",
        "output": "[]",
        "explanation": null
      },
      {
        "input": "lists = [[]]",
        "output": "[]",
        "explanation": null
      }
    ],
    "functionSignature": "def mergeKLists(lists: list[list[int]]) -> list[int]:",
    "starterCode": "def mergeKLists(lists: list[list[int]]) -> list[int]:\n    # Write your solution here\n    pass",
    "tags": [
      "Arrays",
      "Heap",
      "Sorting"
    ],
    "hints": [
      "Use a min-heap (priority queue) to always get the smallest element.",
      "Push the first element of each list, then pop the smallest and push the next from that list."
    ],
    "solutionExplanation": "Use a min-heap. Push (value, list_index, element_index) for each list's first element. Pop smallest, push next element from that list. Time: O(N log k), Space: O(k).",
    "optimalCode": "def mergeKLists(lists: list[list[int]]) -> list[int]:\n    import heapq\n    heap = []\n    for i, lst in enumerate(lists):\n        if lst:\n            heapq.heappush(heap, (lst[0], i, 0))\n    result = []\n    while heap:\n        val, i, j = heapq.heappop(heap)\n        result.append(val)\n        if j + 1 < len(lists[i]):\n            heapq.heappush(heap, (lists[i][j+1], i, j+1))\n    return result"
  },
  {
    "id": "serialize-deserialize-tree",
    "title": "Serialize and Deserialize Binary Tree",
    "difficulty": "Hard",
    "description": "Design an algorithm to serialize a binary tree to a string and deserialize it back. Given a level-order array representing a tree, serialize it to a string and then deserialize it back to the same level-order array. Return the deserialized result.",
    "examples": [
      {
        "input": "root = [1,2,3,None,None,4,5]",
        "output": "[1,2,3,None,None,4,5]",
        "explanation": null
      },
      {
        "input": "root = []",
        "output": "[]",
        "explanation": null
      },
      {
        "input": "root = [1]",
        "output": "[1]",
        "explanation": null
      }
    ],
    "functionSignature": "def codec(root: list) -> list:",
    "starterCode": "def codec(root: list) -> list:\n    # Write your solution here\n    pass",
    "tags": [
      "Tree",
      "DFS",
      "Design"
    ],
    "hints": [
      "You can serialize as comma-separated values with 'null' for None.",
      "For deserialization, parse the string and rebuild the level-order array."
    ],
    "solutionExplanation": "Serialize level-order array to string with comma separator, using 'null' for None. Deserialize by splitting and converting back. Time: O(n), Space: O(n).",
    "optimalCode": "def codec(root: list) -> list:\n    # Serialize\n    serialized = ','.join('null' if v is None else str(v) for v in root) if root else ''\n    # Deserialize\n    if not serialized:\n        return []\n    return [None if v == 'null' else int(v) for v in serialized.split(',')]"
  },
  {
    "id": "alien-dictionary",
    "title": "Alien Dictionary",
    "difficulty": "Hard",
    "description": "There is a new alien language that uses the English alphabet, but the order of letters is unknown. You are given a list of words from the alien dictionary, sorted lexicographically by the alien language's rules. Derive the order of letters. Return a string of the unique letters sorted in the alien language's order. If no valid order exists, return an empty string.",
    "examples": [
      {
        "input": "words = [\"wrt\",\"wrf\",\"er\",\"ett\",\"rftt\"]",
        "output": "\"wertf\"",
        "explanation": null
      },
      {
        "input": "words = [\"z\",\"x\"]",
        "output": "\"zx\"",
        "explanation": null
      },
      {
        "input": "words = [\"z\",\"x\",\"z\"]",
        "output": "\"\"",
        "explanation": "Invalid ordering."
      }
    ],
    "functionSignature": "def alienOrder(words: list[str]) -> str:",
    "starterCode": "def alienOrder(words: list[str]) -> str:\n    # Write your solution here\n    pass",
    "tags": [
      "Graph",
      "Topological Sort"
    ],
    "hints": [
      "Compare adjacent words to find character ordering relationships.",
      "Build a directed graph and perform topological sort."
    ],
    "solutionExplanation": "Compare adjacent words to find edges (character orderings). Build graph and do topological sort with BFS. Detect cycles = invalid. Time: O(C) where C is total characters.",
    "optimalCode": "def alienOrder(words: list[str]) -> str:\n    from collections import defaultdict, deque\n    graph = defaultdict(set)\n    in_degree = {c: 0 for word in words for c in word}\n    for i in range(len(words) - 1):\n        w1, w2 = words[i], words[i+1]\n        min_len = min(len(w1), len(w2))\n        if len(w1) > len(w2) and w1[:min_len] == w2[:min_len]:\n            return ''\n        for j in range(min_len):\n            if w1[j] != w2[j]:\n                if w2[j] not in graph[w1[j]]:\n                    graph[w1[j]].add(w2[j])\n                    in_degree[w2[j]] += 1\n                break\n    queue = deque(c for c in in_degree if in_degree[c] == 0)\n    result = []\n    while queue:\n        c = queue.popleft()\n        result.append(c)\n        for neighbor in graph[c]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    return ''.join(result) if len(result) == len(in_degree) else ''"
  }
]